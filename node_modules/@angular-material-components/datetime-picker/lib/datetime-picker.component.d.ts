/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directionality } from '@angular/cdk/bidi';
import { Overlay, OverlayRef } from '@angular/cdk/overlay';
import { ComponentType } from '@angular/cdk/portal';
import { AfterViewInit, ElementRef, EventEmitter, NgZone, OnDestroy, ViewContainerRef } from '@angular/core';
import { CanColor, CanColorCtor, ThemePalette } from '@angular/material/core';
import { MatCalendarCellCssClasses } from '@angular/material/datepicker';
import { MatDialog } from '@angular/material/dialog';
import { NgxMatDateAdapter } from './core/date-adapter';
import { Subject } from 'rxjs';
import { NgxMatCalendar } from './calendar';
import { NgxMatDatetimeInput } from './datetime-input';
import { NgxMatTimepickerComponent } from './timepicker.component';
/** @docs-private */
import * as ɵngcc0 from '@angular/core';
declare class MatDatepickerContentBase {
    _elementRef: ElementRef;
    constructor(_elementRef: ElementRef);
}
declare const _MatDatepickerContentMixinBase: CanColorCtor & typeof MatDatepickerContentBase;
/**
 * Component used as the content for the datepicker dialog and popup. We use this instead of using
 * NgxMatCalendar directly as the content so we can control the initial focus. This also gives us a
 * place to put additional features of the popup that are not part of the calendar itself in the
 * future. (e.g. confirmation buttons).
 * @docs-private
 */
export declare class NgxMatDatetimeContent<D> extends _MatDatepickerContentMixinBase implements AfterViewInit, CanColor {
    /** Reference to the internal calendar component. */
    _calendar: NgxMatCalendar<D>;
    /** Reference to the internal time picker component. */
    _timePicker: NgxMatTimepickerComponent<D>;
    /** Reference to the datepicker that created the overlay. */
    datepicker: NgxMatDatetimePicker<D>;
    /** Whether the datepicker is above or below the input. */
    _isAbove: boolean;
    /** Whether or not the selected date is valid (min,max...) */
    readonly valid: boolean;
    readonly isViewMonth: boolean;
    constructor(elementRef: ElementRef);
    ngAfterViewInit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgxMatDatetimeContent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgxMatDatetimeContent<any>, "ngx-mat-datetime-content", ["ngxMatDatetimeContent"], {
    "color": "color";
}, {}, never>;
}
/** Component responsible for managing the datepicker popup/dialog. */
export declare class NgxMatDatetimePicker<D> implements OnDestroy, CanColor {
    private _dialog;
    private _overlay;
    private _ngZone;
    private _viewContainerRef;
    private _dateAdapter;
    private _dir;
    private _document;
    private _scrollStrategy;
    /** An input indicating the type of the custom header component for the calendar, if set. */
    calendarHeaderComponent: ComponentType<any>;
    /** The date to open the calendar to initially. */
    startAt: D | null;
    private _startAt;
    /** The view that the calendar should start in. */
    startView: 'month' | 'year' | 'multi-year';
    /** Color palette to use on the datepicker's calendar. */
    color: ThemePalette;
    _color: ThemePalette;
    /**
     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
     * than a popup and elements have more padding to allow for bigger touch targets.
     */
    touchUi: boolean;
    private _touchUi;
    hideTime: boolean;
    _hideTime: boolean;
    /** Whether the datepicker pop-up should be disabled. */
    disabled: boolean;
    _disabled: boolean;
    /**
     * Emits selected year in multiyear view.
     * This doesn't imply a change on the selected date.
     */
    readonly yearSelected: EventEmitter<D>;
    /**
     * Emits selected month in year view.
     * This doesn't imply a change on the selected date.
     */
    readonly monthSelected: EventEmitter<D>;
    /** Classes to be passed to the date picker panel. Supports the same syntax as `ngClass`. */
    panelClass: string | string[];
    /** Function that can be used to add custom CSS classes to dates. */
    dateClass: (date: D) => MatCalendarCellCssClasses;
    /** Emits when the datepicker has been opened. */
    openedStream: EventEmitter<void>;
    /** Emits when the datepicker has been closed. */
    closedStream: EventEmitter<void>;
    /** Whether the calendar is open. */
    opened: boolean;
    private _opened;
    /** Whether the timepicker'spinners is shown. */
    showSpinners: boolean;
    _showSpinners: boolean;
    /** Whether the second part is disabled. */
    showSeconds: boolean;
    _showSeconds: boolean;
    /** Step hour */
    stepHour: number;
    _stepHour: number;
    /** Step minute */
    stepMinute: number;
    _stepMinute: number;
    /** Step second */
    stepSecond: number;
    _stepSecond: number;
    /** Enable meridian */
    enableMeridian: boolean;
    _enableMeridian: boolean;
    /** disable minute */
    disableMinute: boolean;
    _disableMinute: boolean;
    /** Step second */
    defaultTime: number[];
    _defaultTime: number[];
    private _hasBackdrop;
    /** The id for the datepicker calendar. */
    id: string;
    /** The currently selected date. */
    _selected: D | null;
    private _validSelected;
    /** The minimum selectable date. */
    readonly _minDate: D | null;
    /** The maximum selectable date. */
    readonly _maxDate: D | null;
    readonly valid: boolean;
    readonly _dateFilter: (date: D | null) => boolean;
    /** A reference to the overlay when the calendar is opened as a popup. */
    _popupRef: OverlayRef;
    /** A reference to the dialog when the calendar is opened as a dialog. */
    private _dialogRef;
    /** A portal containing the calendar for this datepicker. */
    private _calendarPortal;
    /** Reference to the component instantiated in popup mode. */
    private _popupComponentRef;
    /** The element that was focused before the datepicker was opened. */
    private _focusedElementBeforeOpen;
    /** Subscription to value changes in the associated input element. */
    private _inputSubscription;
    /** The input element this datepicker is associated with. */
    _datepickerInput: NgxMatDatetimeInput<D>;
    /** Emits when the datepicker is disabled. */
    readonly _disabledChange: Subject<boolean>;
    /** Emits new selected date when selected date changes. */
    readonly _selectedChanged: Subject<D>;
    /** Raw value before  */
    private _rawValue;
    constructor(_dialog: MatDialog, _overlay: Overlay, _ngZone: NgZone, _viewContainerRef: ViewContainerRef, scrollStrategy: any, _dateAdapter: NgxMatDateAdapter<D>, _dir: Directionality, _document: any);
    ngOnDestroy(): void;
    /** The form control validator for the min date. */
    private _minValidator;
    /** The form control validator for the max date. */
    private _maxValidator;
    /** Selects the given date */
    select(date: D): void;
    /** Emits the selected year in multiyear view */
    _selectYear(normalizedYear: D): void;
    /** Emits selected month in year view */
    _selectMonth(normalizedMonth: D): void;
    /** OK button handler and close*/
    ok(): void;
    /** Cancel and close */
    cancel(): void;
    /**
     * Register an input with this datepicker.
     * @param input The datepicker input to register with this datepicker.
     */
    _registerInput(input: NgxMatDatetimeInput<D>): void;
    /** Open the calendar. */
    open(): void;
    /** Close the calendar. */
    close(): void;
    /** Open the calendar as a dialog. */
    private _openAsDialog;
    /** Open the calendar as a popup. */
    private _openAsPopup;
    /** Create the popup. */
    private _createPopup;
    /** Create the popup PositionStrategy. */
    private _createPopupPositionStrategy;
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    private _getValidDateOrNull;
    /** Passes the current theme color along to the calendar overlay. */
    private _setColor;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgxMatDatetimePicker<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgxMatDatetimePicker<any>, "ngx-mat-datetime-picker", ["ngxMatDatetimePicker"], {
    "startView": "startView";
    "startAt": "startAt";
    "color": "color";
    "touchUi": "touchUi";
    "hideTime": "hideTime";
    "disabled": "disabled";
    "opened": "opened";
    "showSpinners": "showSpinners";
    "showSeconds": "showSeconds";
    "stepHour": "stepHour";
    "stepMinute": "stepMinute";
    "stepSecond": "stepSecond";
    "enableMeridian": "enableMeridian";
    "disableMinute": "disableMinute";
    "defaultTime": "defaultTime";
    "calendarHeaderComponent": "calendarHeaderComponent";
    "panelClass": "panelClass";
    "dateClass": "dateClass";
}, {
    "yearSelected": "yearSelected";
    "monthSelected": "monthSelected";
    "openedStream": "opened";
    "closedStream": "closed";
}, never>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWUtcGlja2VyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJkYXRldGltZS1waWNrZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUpBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xyXG5pbXBvcnQgeyBPdmVybGF5LCBPdmVybGF5UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xyXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XHJcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ2FuQ29sb3IsIENhbkNvbG9yQ3RvciwgVGhlbWVQYWxldHRlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XHJcbmltcG9ydCB7IE1hdENhbGVuZGFyQ2VsbENzc0NsYXNzZXMgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9kYXRlcGlja2VyJztcclxuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcclxuaW1wb3J0IHsgTmd4TWF0RGF0ZUFkYXB0ZXIgfSBmcm9tICcuL2NvcmUvZGF0ZS1hZGFwdGVyJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBOZ3hNYXRDYWxlbmRhciB9IGZyb20gJy4vY2FsZW5kYXInO1xyXG5pbXBvcnQgeyBOZ3hNYXREYXRldGltZUlucHV0IH0gZnJvbSAnLi9kYXRldGltZS1pbnB1dCc7XHJcbmltcG9ydCB7IE5neE1hdFRpbWVwaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL3RpbWVwaWNrZXIuY29tcG9uZW50JztcclxuLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuZGVjbGFyZSBjbGFzcyBNYXREYXRlcGlja2VyQ29udGVudEJhc2Uge1xyXG4gICAgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XHJcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZjogRWxlbWVudFJlZik7XHJcbn1cclxuZGVjbGFyZSBjb25zdCBfTWF0RGF0ZXBpY2tlckNvbnRlbnRNaXhpbkJhc2U6IENhbkNvbG9yQ3RvciAmIHR5cGVvZiBNYXREYXRlcGlja2VyQ29udGVudEJhc2U7XHJcbi8qKlxyXG4gKiBDb21wb25lbnQgdXNlZCBhcyB0aGUgY29udGVudCBmb3IgdGhlIGRhdGVwaWNrZXIgZGlhbG9nIGFuZCBwb3B1cC4gV2UgdXNlIHRoaXMgaW5zdGVhZCBvZiB1c2luZ1xyXG4gKiBOZ3hNYXRDYWxlbmRhciBkaXJlY3RseSBhcyB0aGUgY29udGVudCBzbyB3ZSBjYW4gY29udHJvbCB0aGUgaW5pdGlhbCBmb2N1cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFcclxuICogcGxhY2UgdG8gcHV0IGFkZGl0aW9uYWwgZmVhdHVyZXMgb2YgdGhlIHBvcHVwIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjYWxlbmRhciBpdHNlbGYgaW4gdGhlXHJcbiAqIGZ1dHVyZS4gKGUuZy4gY29uZmlybWF0aW9uIGJ1dHRvbnMpLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ3hNYXREYXRldGltZUNvbnRlbnQ8RD4gZXh0ZW5kcyBfTWF0RGF0ZXBpY2tlckNvbnRlbnRNaXhpbkJhc2UgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBDYW5Db2xvciB7XHJcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBjYWxlbmRhciBjb21wb25lbnQuICovXHJcbiAgICBfY2FsZW5kYXI6IE5neE1hdENhbGVuZGFyPEQ+O1xyXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgdGltZSBwaWNrZXIgY29tcG9uZW50LiAqL1xyXG4gICAgX3RpbWVQaWNrZXI6IE5neE1hdFRpbWVwaWNrZXJDb21wb25lbnQ8RD47XHJcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBkYXRlcGlja2VyIHRoYXQgY3JlYXRlZCB0aGUgb3ZlcmxheS4gKi9cclxuICAgIGRhdGVwaWNrZXI6IE5neE1hdERhdGV0aW1lUGlja2VyPEQ+O1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGRhdGVwaWNrZXIgaXMgYWJvdmUgb3IgYmVsb3cgdGhlIGlucHV0LiAqL1xyXG4gICAgX2lzQWJvdmU6IGJvb2xlYW47XHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHNlbGVjdGVkIGRhdGUgaXMgdmFsaWQgKG1pbixtYXguLi4pICovXHJcbiAgICByZWFkb25seSB2YWxpZDogYm9vbGVhbjtcclxuICAgIHJlYWRvbmx5IGlzVmlld01vbnRoOiBib29sZWFuO1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZik7XHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcclxufVxyXG4vKiogQ29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB0aGUgZGF0ZXBpY2tlciBwb3B1cC9kaWFsb2cuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5neE1hdERhdGV0aW1lUGlja2VyPEQ+IGltcGxlbWVudHMgT25EZXN0cm95LCBDYW5Db2xvciB7XHJcbiAgICBwcml2YXRlIF9kaWFsb2c7XHJcbiAgICBwcml2YXRlIF9vdmVybGF5O1xyXG4gICAgcHJpdmF0ZSBfbmdab25lO1xyXG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjtcclxuICAgIHByaXZhdGUgX2RhdGVBZGFwdGVyO1xyXG4gICAgcHJpdmF0ZSBfZGlyO1xyXG4gICAgcHJpdmF0ZSBfZG9jdW1lbnQ7XHJcbiAgICBwcml2YXRlIF9zY3JvbGxTdHJhdGVneTtcclxuICAgIC8qKiBBbiBpbnB1dCBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIHRoZSBjdXN0b20gaGVhZGVyIGNvbXBvbmVudCBmb3IgdGhlIGNhbGVuZGFyLCBpZiBzZXQuICovXHJcbiAgICBjYWxlbmRhckhlYWRlckNvbXBvbmVudDogQ29tcG9uZW50VHlwZTxhbnk+O1xyXG4gICAgLyoqIFRoZSBkYXRlIHRvIG9wZW4gdGhlIGNhbGVuZGFyIHRvIGluaXRpYWxseS4gKi9cclxuICAgIHN0YXJ0QXQ6IEQgfCBudWxsO1xyXG4gICAgcHJpdmF0ZSBfc3RhcnRBdDtcclxuICAgIC8qKiBUaGUgdmlldyB0aGF0IHRoZSBjYWxlbmRhciBzaG91bGQgc3RhcnQgaW4uICovXHJcbiAgICBzdGFydFZpZXc6ICdtb250aCcgfCAneWVhcicgfCAnbXVsdGkteWVhcic7XHJcbiAgICAvKiogQ29sb3IgcGFsZXR0ZSB0byB1c2Ugb24gdGhlIGRhdGVwaWNrZXIncyBjYWxlbmRhci4gKi9cclxuICAgIGNvbG9yOiBUaGVtZVBhbGV0dGU7XHJcbiAgICBfY29sb3I6IFRoZW1lUGFsZXR0ZTtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgY2FsZW5kYXIgVUkgaXMgaW4gdG91Y2ggbW9kZS4gSW4gdG91Y2ggbW9kZSB0aGUgY2FsZW5kYXIgb3BlbnMgaW4gYSBkaWFsb2cgcmF0aGVyXHJcbiAgICAgKiB0aGFuIGEgcG9wdXAgYW5kIGVsZW1lbnRzIGhhdmUgbW9yZSBwYWRkaW5nIHRvIGFsbG93IGZvciBiaWdnZXIgdG91Y2ggdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgdG91Y2hVaTogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX3RvdWNoVWk7XHJcbiAgICBoaWRlVGltZTogYm9vbGVhbjtcclxuICAgIF9oaWRlVGltZTogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBkYXRlcGlja2VyIHBvcC11cCBzaG91bGQgYmUgZGlzYWJsZWQuICovXHJcbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIF9kaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogRW1pdHMgc2VsZWN0ZWQgeWVhciBpbiBtdWx0aXllYXIgdmlldy5cclxuICAgICAqIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZS5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgeWVhclNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8RD47XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIHNlbGVjdGVkIG1vbnRoIGluIHllYXIgdmlldy5cclxuICAgICAqIFRoaXMgZG9lc24ndCBpbXBseSBhIGNoYW5nZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZS5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgbW9udGhTZWxlY3RlZDogRXZlbnRFbWl0dGVyPEQ+O1xyXG4gICAgLyoqIENsYXNzZXMgdG8gYmUgcGFzc2VkIHRvIHRoZSBkYXRlIHBpY2tlciBwYW5lbC4gU3VwcG9ydHMgdGhlIHNhbWUgc3ludGF4IGFzIGBuZ0NsYXNzYC4gKi9cclxuICAgIHBhbmVsQ2xhc3M6IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4gICAgLyoqIEZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGN1c3RvbSBDU1MgY2xhc3NlcyB0byBkYXRlcy4gKi9cclxuICAgIGRhdGVDbGFzczogKGRhdGU6IEQpID0+IE1hdENhbGVuZGFyQ2VsbENzc0NsYXNzZXM7XHJcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgZGF0ZXBpY2tlciBoYXMgYmVlbiBvcGVuZWQuICovXHJcbiAgICBvcGVuZWRTdHJlYW06IEV2ZW50RW1pdHRlcjx2b2lkPjtcclxuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBkYXRlcGlja2VyIGhhcyBiZWVuIGNsb3NlZC4gKi9cclxuICAgIGNsb3NlZFN0cmVhbTogRXZlbnRFbWl0dGVyPHZvaWQ+O1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIG9wZW4uICovXHJcbiAgICBvcGVuZWQ6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9vcGVuZWQ7XHJcbiAgICAvKiogV2hldGhlciB0aGUgdGltZXBpY2tlcidzcGlubmVycyBpcyBzaG93bi4gKi9cclxuICAgIHNob3dTcGlubmVyczogYm9vbGVhbjtcclxuICAgIF9zaG93U3Bpbm5lcnM6IGJvb2xlYW47XHJcbiAgICAvKiogV2hldGhlciB0aGUgc2Vjb25kIHBhcnQgaXMgZGlzYWJsZWQuICovXHJcbiAgICBzaG93U2Vjb25kczogYm9vbGVhbjtcclxuICAgIF9zaG93U2Vjb25kczogYm9vbGVhbjtcclxuICAgIC8qKiBTdGVwIGhvdXIgKi9cclxuICAgIHN0ZXBIb3VyOiBudW1iZXI7XHJcbiAgICBfc3RlcEhvdXI6IG51bWJlcjtcclxuICAgIC8qKiBTdGVwIG1pbnV0ZSAqL1xyXG4gICAgc3RlcE1pbnV0ZTogbnVtYmVyO1xyXG4gICAgX3N0ZXBNaW51dGU6IG51bWJlcjtcclxuICAgIC8qKiBTdGVwIHNlY29uZCAqL1xyXG4gICAgc3RlcFNlY29uZDogbnVtYmVyO1xyXG4gICAgX3N0ZXBTZWNvbmQ6IG51bWJlcjtcclxuICAgIC8qKiBFbmFibGUgbWVyaWRpYW4gKi9cclxuICAgIGVuYWJsZU1lcmlkaWFuOiBib29sZWFuO1xyXG4gICAgX2VuYWJsZU1lcmlkaWFuOiBib29sZWFuO1xyXG4gICAgLyoqIGRpc2FibGUgbWludXRlICovXHJcbiAgICBkaXNhYmxlTWludXRlOiBib29sZWFuO1xyXG4gICAgX2Rpc2FibGVNaW51dGU6IGJvb2xlYW47XHJcbiAgICAvKiogU3RlcCBzZWNvbmQgKi9cclxuICAgIGRlZmF1bHRUaW1lOiBudW1iZXJbXTtcclxuICAgIF9kZWZhdWx0VGltZTogbnVtYmVyW107XHJcbiAgICBwcml2YXRlIF9oYXNCYWNrZHJvcDtcclxuICAgIC8qKiBUaGUgaWQgZm9yIHRoZSBkYXRlcGlja2VyIGNhbGVuZGFyLiAqL1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXHJcbiAgICBfc2VsZWN0ZWQ6IEQgfCBudWxsO1xyXG4gICAgcHJpdmF0ZSBfdmFsaWRTZWxlY3RlZDtcclxuICAgIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuICovXHJcbiAgICByZWFkb25seSBfbWluRGF0ZTogRCB8IG51bGw7XHJcbiAgICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xyXG4gICAgcmVhZG9ubHkgX21heERhdGU6IEQgfCBudWxsO1xyXG4gICAgcmVhZG9ubHkgdmFsaWQ6IGJvb2xlYW47XHJcbiAgICByZWFkb25seSBfZGF0ZUZpbHRlcjogKGRhdGU6IEQgfCBudWxsKSA9PiBib29sZWFuO1xyXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IHdoZW4gdGhlIGNhbGVuZGFyIGlzIG9wZW5lZCBhcyBhIHBvcHVwLiAqL1xyXG4gICAgX3BvcHVwUmVmOiBPdmVybGF5UmVmO1xyXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBkaWFsb2cgd2hlbiB0aGUgY2FsZW5kYXIgaXMgb3BlbmVkIGFzIGEgZGlhbG9nLiAqL1xyXG4gICAgcHJpdmF0ZSBfZGlhbG9nUmVmO1xyXG4gICAgLyoqIEEgcG9ydGFsIGNvbnRhaW5pbmcgdGhlIGNhbGVuZGFyIGZvciB0aGlzIGRhdGVwaWNrZXIuICovXHJcbiAgICBwcml2YXRlIF9jYWxlbmRhclBvcnRhbDtcclxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW50aWF0ZWQgaW4gcG9wdXAgbW9kZS4gKi9cclxuICAgIHByaXZhdGUgX3BvcHVwQ29tcG9uZW50UmVmO1xyXG4gICAgLyoqIFRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkYXRlcGlja2VyIHdhcyBvcGVuZWQuICovXHJcbiAgICBwcml2YXRlIF9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW47XHJcbiAgICAvKiogU3Vic2NyaXB0aW9uIHRvIHZhbHVlIGNoYW5nZXMgaW4gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gKi9cclxuICAgIHByaXZhdGUgX2lucHV0U3Vic2NyaXB0aW9uO1xyXG4gICAgLyoqIFRoZSBpbnB1dCBlbGVtZW50IHRoaXMgZGF0ZXBpY2tlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXHJcbiAgICBfZGF0ZXBpY2tlcklucHV0OiBOZ3hNYXREYXRldGltZUlucHV0PEQ+O1xyXG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgZGlzYWJsZWQuICovXHJcbiAgICByZWFkb25seSBfZGlzYWJsZWRDaGFuZ2U6IFN1YmplY3Q8Ym9vbGVhbj47XHJcbiAgICAvKiogRW1pdHMgbmV3IHNlbGVjdGVkIGRhdGUgd2hlbiBzZWxlY3RlZCBkYXRlIGNoYW5nZXMuICovXHJcbiAgICByZWFkb25seSBfc2VsZWN0ZWRDaGFuZ2VkOiBTdWJqZWN0PEQ+O1xyXG4gICAgLyoqIFJhdyB2YWx1ZSBiZWZvcmUgICovXHJcbiAgICBwcml2YXRlIF9yYXdWYWx1ZTtcclxuICAgIGNvbnN0cnVjdG9yKF9kaWFsb2c6IE1hdERpYWxvZywgX292ZXJsYXk6IE92ZXJsYXksIF9uZ1pvbmU6IE5nWm9uZSwgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsIHNjcm9sbFN0cmF0ZWd5OiBhbnksIF9kYXRlQWRhcHRlcjogTmd4TWF0RGF0ZUFkYXB0ZXI8RD4sIF9kaXI6IERpcmVjdGlvbmFsaXR5LCBfZG9jdW1lbnQ6IGFueSk7XHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xyXG4gICAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgbWluIGRhdGUuICovXHJcbiAgICBwcml2YXRlIF9taW5WYWxpZGF0b3I7XHJcbiAgICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtYXggZGF0ZS4gKi9cclxuICAgIHByaXZhdGUgX21heFZhbGlkYXRvcjtcclxuICAgIC8qKiBTZWxlY3RzIHRoZSBnaXZlbiBkYXRlICovXHJcbiAgICBzZWxlY3QoZGF0ZTogRCk6IHZvaWQ7XHJcbiAgICAvKiogRW1pdHMgdGhlIHNlbGVjdGVkIHllYXIgaW4gbXVsdGl5ZWFyIHZpZXcgKi9cclxuICAgIF9zZWxlY3RZZWFyKG5vcm1hbGl6ZWRZZWFyOiBEKTogdm9pZDtcclxuICAgIC8qKiBFbWl0cyBzZWxlY3RlZCBtb250aCBpbiB5ZWFyIHZpZXcgKi9cclxuICAgIF9zZWxlY3RNb250aChub3JtYWxpemVkTW9udGg6IEQpOiB2b2lkO1xyXG4gICAgLyoqIE9LIGJ1dHRvbiBoYW5kbGVyIGFuZCBjbG9zZSovXHJcbiAgICBvaygpOiB2b2lkO1xyXG4gICAgLyoqIENhbmNlbCBhbmQgY2xvc2UgKi9cclxuICAgIGNhbmNlbCgpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhbiBpbnB1dCB3aXRoIHRoaXMgZGF0ZXBpY2tlci5cclxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgZGF0ZXBpY2tlciBpbnB1dCB0byByZWdpc3RlciB3aXRoIHRoaXMgZGF0ZXBpY2tlci5cclxuICAgICAqL1xyXG4gICAgX3JlZ2lzdGVySW5wdXQoaW5wdXQ6IE5neE1hdERhdGV0aW1lSW5wdXQ8RD4pOiB2b2lkO1xyXG4gICAgLyoqIE9wZW4gdGhlIGNhbGVuZGFyLiAqL1xyXG4gICAgb3BlbigpOiB2b2lkO1xyXG4gICAgLyoqIENsb3NlIHRoZSBjYWxlbmRhci4gKi9cclxuICAgIGNsb3NlKCk6IHZvaWQ7XHJcbiAgICAvKiogT3BlbiB0aGUgY2FsZW5kYXIgYXMgYSBkaWFsb2cuICovXHJcbiAgICBwcml2YXRlIF9vcGVuQXNEaWFsb2c7XHJcbiAgICAvKiogT3BlbiB0aGUgY2FsZW5kYXIgYXMgYSBwb3B1cC4gKi9cclxuICAgIHByaXZhdGUgX29wZW5Bc1BvcHVwO1xyXG4gICAgLyoqIENyZWF0ZSB0aGUgcG9wdXAuICovXHJcbiAgICBwcml2YXRlIF9jcmVhdGVQb3B1cDtcclxuICAgIC8qKiBDcmVhdGUgdGhlIHBvcHVwIFBvc2l0aW9uU3RyYXRlZ3kuICovXHJcbiAgICBwcml2YXRlIF9jcmVhdGVQb3B1cFBvc2l0aW9uU3RyYXRlZ3k7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIFRoZSBnaXZlbiBvYmplY3QgaWYgaXQgaXMgYm90aCBhIGRhdGUgaW5zdGFuY2UgYW5kIHZhbGlkLCBvdGhlcndpc2UgbnVsbC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0VmFsaWREYXRlT3JOdWxsO1xyXG4gICAgLyoqIFBhc3NlcyB0aGUgY3VycmVudCB0aGVtZSBjb2xvciBhbG9uZyB0byB0aGUgY2FsZW5kYXIgb3ZlcmxheS4gKi9cclxuICAgIHByaXZhdGUgX3NldENvbG9yO1xyXG59XHJcbmV4cG9ydCB7fTtcclxuIl19