import { ControlValueAccessor, NgForm, NgControl, FormGroupDirective } from '@angular/forms';
import { OnInit, EventEmitter, ElementRef, OnChanges, Renderer2, AfterViewInit, OnDestroy, SimpleChanges, NgZone, TemplateRef } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatFormFieldControl, MatFormField } from '@angular/material/form-field';
import { ClockMode } from './interfaces-and-types';
import { Subject } from 'rxjs';
import { FocusMonitor } from '@angular/cdk/a11y';
import { ErrorStateMatcher } from '@angular/material/core';
import { Platform } from '@angular/cdk/platform';
import * as ɵngcc0 from '@angular/core';
export interface MatTimepickerButtonTemplateContext {
    $implicit: () => void;
    label: string;
}
export declare class MatTimepickerDirective implements OnInit, OnChanges, AfterViewInit, OnDestroy, ControlValueAccessor, MatFormFieldControl<any> {
    ngControl: NgControl;
    dialog: MatDialog;
    private renderer;
    private zone;
    private fm;
    private elRef;
    private ngZone;
    protected _platform: Platform;
    private _parentForm;
    private _matFormFiled;
    private _parentFormGroup;
    static nextId: number;
    /** Whether the component is being rendered on the server. */
    readonly _isServer: boolean;
    _errorState: boolean;
    get errorState(): boolean;
    get disabled(): boolean;
    set disabled(value: boolean);
    protected _disabled: boolean;
    get id(): string;
    set id(value: string);
    protected _id: string;
    get readonly(): boolean;
    set readonly(value: boolean);
    private _readonly;
    private isAlive;
    stateChanges: Subject<void>;
    protected _uid: string;
    get shouldLabelFloat(): boolean;
    describedBy: string;
    errorStateMatcher: ErrorStateMatcher;
    get required(): boolean;
    set required(req: boolean);
    private _required;
    get placeholder(): string;
    set placeholder(plh: string);
    private _placeholder;
    focused: boolean;
    private pattern;
    private allowed24HourMap;
    private allowed12HourMap;
    private isInputFocused;
    okButtonTemplate: TemplateRef<MatTimepickerButtonTemplateContext> | null;
    cancelButtonTemplate: TemplateRef<MatTimepickerButtonTemplateContext> | null;
    /** Override the label of the ok button. */
    okLabel: string;
    /** Override the label of the cancel button. */
    cancelLabel: string;
    /** Override the ante meridiem abbreviation. */
    anteMeridiemAbbreviation: string;
    /** Override the post meridiem abbreviation. */
    postMeridiemAbbreviation: string;
    /** Sets the clock mode, 12-hour or 24-hour clocks are supported. */
    mode: ClockMode;
    color: string;
    disableDialogOpenOnClick: boolean;
    strict: boolean;
    controlType: string;
    private listeners;
    minDate: Date;
    maxDate: Date;
    private _isPm;
    private _value;
    private _formattedValueString;
    private _skipValueChangeEmission;
    set value(value: Date);
    get value(): Date;
    get isPm(): boolean;
    get empty(): boolean;
    private get formattedValueString();
    private currentValue;
    private modalRef;
    private onChangeFn;
    private onTouchedFn;
    private combination;
    timeChange: EventEmitter<any>;
    invalidInput: EventEmitter<any>;
    inputHandler(): void;
    keydownHandler(event: any): boolean;
    keyupHandler(event: any): void;
    focusHandler(): void;
    focusoutHandler(): void;
    constructor(ngControl: NgControl, dialog: MatDialog, renderer: Renderer2, zone: NgZone, fm: FocusMonitor, elRef: ElementRef<HTMLElement>, ngZone: NgZone, _platform: Platform, _parentForm: NgForm, _matFormFiled: MatFormField, _parentFormGroup: FormGroupDirective, _defaultErrorStateMatcher: ErrorStateMatcher);
    setDescribedByIds(ids: string[]): void;
    onContainerClick(event: MouseEvent): void;
    setInputElementValue(value: any): void;
    validate(): {
        dateRange: boolean;
    };
    ngAfterViewInit(): void;
    clickHandler: (e: FocusEvent) => void;
    ngOnInit(): void;
    generateAllowedMap(): void;
    ngOnChanges(simpleChanges: SimpleChanges): void;
    checkValidity(value: Date): boolean;
    writeValue(value: Date, isInnerCall?: boolean): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState?(isDisabled: boolean): void;
    showDialog(): void;
    handleChange: (newValue: any) => void;
    handleOk: (value: any) => void;
    handleCancel: () => void;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatTimepickerDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<MatTimepickerDirective, "input[matTimepicker]", ["matTimepicker"], {
    "okButtonTemplate": "okButtonTemplate";
    "cancelButtonTemplate": "cancelButtonTemplate";
    "okLabel": "okLabel";
    "cancelLabel": "cancelLabel";
    "anteMeridiemAbbreviation": "anteMeridiemAbbreviation";
    "postMeridiemAbbreviation": "postMeridiemAbbreviation";
    "mode": "mode";
    "color": "color";
    "disableDialogOpenOnClick": "disableDialogOpenOnClick";
    "strict": "strict";
    "value": "value";
    "id": "id";
    "errorStateMatcher": "errorStateMatcher";
    "disabled": "disabled";
    "readonly": "readonly";
    "required": "required";
    "placeholder": "placeholder";
    "minDate": "minDate";
    "maxDate": "maxDate";
}, {
    "timeChange": "timeChange";
    "invalidInput": "invalidInput";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXBpY2tlci5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsidGltZXBpY2tlci5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZHQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ0Zvcm0sIE5nQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgT25Jbml0LCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIE9uQ2hhbmdlcywgUmVuZGVyZXIyLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIFNpbXBsZUNoYW5nZXMsIE5nWm9uZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hdERpYWxvZyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2RpYWxvZyc7XG5pbXBvcnQgeyBNYXRGb3JtRmllbGRDb250cm9sLCBNYXRGb3JtRmllbGQgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9mb3JtLWZpZWxkJztcbmltcG9ydCB7IENsb2NrTW9kZSB9IGZyb20gJy4vaW50ZXJmYWNlcy1hbmQtdHlwZXMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRm9jdXNNb25pdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmV4cG9ydCBpbnRlcmZhY2UgTWF0VGltZXBpY2tlckJ1dHRvblRlbXBsYXRlQ29udGV4dCB7XG4gICAgJGltcGxpY2l0OiAoKSA9PiB2b2lkO1xuICAgIGxhYmVsOiBzdHJpbmc7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXRUaW1lcGlja2VyRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE1hdEZvcm1GaWVsZENvbnRyb2w8YW55PiB7XG4gICAgbmdDb250cm9sOiBOZ0NvbnRyb2w7XG4gICAgZGlhbG9nOiBNYXREaWFsb2c7XG4gICAgcHJpdmF0ZSByZW5kZXJlcjtcbiAgICBwcml2YXRlIHpvbmU7XG4gICAgcHJpdmF0ZSBmbTtcbiAgICBwcml2YXRlIGVsUmVmO1xuICAgIHByaXZhdGUgbmdab25lO1xuICAgIHByb3RlY3RlZCBfcGxhdGZvcm06IFBsYXRmb3JtO1xuICAgIHByaXZhdGUgX3BhcmVudEZvcm07XG4gICAgcHJpdmF0ZSBfbWF0Rm9ybUZpbGVkO1xuICAgIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDtcbiAgICBzdGF0aWMgbmV4dElkOiBudW1iZXI7XG4gICAgLyoqIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBiZWluZyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiAqL1xuICAgIHJlYWRvbmx5IF9pc1NlcnZlcjogYm9vbGVhbjtcbiAgICBfZXJyb3JTdGF0ZTogYm9vbGVhbjtcbiAgICBnZXQgZXJyb3JTdGF0ZSgpOiBib29sZWFuO1xuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuO1xuICAgIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbik7XG4gICAgcHJvdGVjdGVkIF9kaXNhYmxlZDogYm9vbGVhbjtcbiAgICBnZXQgaWQoKTogc3RyaW5nO1xuICAgIHNldCBpZCh2YWx1ZTogc3RyaW5nKTtcbiAgICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmc7XG4gICAgZ2V0IHJlYWRvbmx5KCk6IGJvb2xlYW47XG4gICAgc2V0IHJlYWRvbmx5KHZhbHVlOiBib29sZWFuKTtcbiAgICBwcml2YXRlIF9yZWFkb25seTtcbiAgICBwcml2YXRlIGlzQWxpdmU7XG4gICAgc3RhdGVDaGFuZ2VzOiBTdWJqZWN0PHZvaWQ+O1xuICAgIHByb3RlY3RlZCBfdWlkOiBzdHJpbmc7XG4gICAgZ2V0IHNob3VsZExhYmVsRmxvYXQoKTogYm9vbGVhbjtcbiAgICBkZXNjcmliZWRCeTogc3RyaW5nO1xuICAgIGVycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcjtcbiAgICBnZXQgcmVxdWlyZWQoKTogYm9vbGVhbjtcbiAgICBzZXQgcmVxdWlyZWQocmVxOiBib29sZWFuKTtcbiAgICBwcml2YXRlIF9yZXF1aXJlZDtcbiAgICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nO1xuICAgIHNldCBwbGFjZWhvbGRlcihwbGg6IHN0cmluZyk7XG4gICAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI7XG4gICAgZm9jdXNlZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIHBhdHRlcm47XG4gICAgcHJpdmF0ZSBhbGxvd2VkMjRIb3VyTWFwO1xuICAgIHByaXZhdGUgYWxsb3dlZDEySG91ck1hcDtcbiAgICBwcml2YXRlIGlzSW5wdXRGb2N1c2VkO1xuICAgIG9rQnV0dG9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPE1hdFRpbWVwaWNrZXJCdXR0b25UZW1wbGF0ZUNvbnRleHQ+IHwgbnVsbDtcbiAgICBjYW5jZWxCdXR0b25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8TWF0VGltZXBpY2tlckJ1dHRvblRlbXBsYXRlQ29udGV4dD4gfCBudWxsO1xuICAgIC8qKiBPdmVycmlkZSB0aGUgbGFiZWwgb2YgdGhlIG9rIGJ1dHRvbi4gKi9cbiAgICBva0xhYmVsOiBzdHJpbmc7XG4gICAgLyoqIE92ZXJyaWRlIHRoZSBsYWJlbCBvZiB0aGUgY2FuY2VsIGJ1dHRvbi4gKi9cbiAgICBjYW5jZWxMYWJlbDogc3RyaW5nO1xuICAgIC8qKiBPdmVycmlkZSB0aGUgYW50ZSBtZXJpZGllbSBhYmJyZXZpYXRpb24uICovXG4gICAgYW50ZU1lcmlkaWVtQWJicmV2aWF0aW9uOiBzdHJpbmc7XG4gICAgLyoqIE92ZXJyaWRlIHRoZSBwb3N0IG1lcmlkaWVtIGFiYnJldmlhdGlvbi4gKi9cbiAgICBwb3N0TWVyaWRpZW1BYmJyZXZpYXRpb246IHN0cmluZztcbiAgICAvKiogU2V0cyB0aGUgY2xvY2sgbW9kZSwgMTItaG91ciBvciAyNC1ob3VyIGNsb2NrcyBhcmUgc3VwcG9ydGVkLiAqL1xuICAgIG1vZGU6IENsb2NrTW9kZTtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGRpc2FibGVEaWFsb2dPcGVuT25DbGljazogYm9vbGVhbjtcbiAgICBzdHJpY3Q6IGJvb2xlYW47XG4gICAgY29udHJvbFR5cGU6IHN0cmluZztcbiAgICBwcml2YXRlIGxpc3RlbmVycztcbiAgICBtaW5EYXRlOiBEYXRlO1xuICAgIG1heERhdGU6IERhdGU7XG4gICAgcHJpdmF0ZSBfaXNQbTtcbiAgICBwcml2YXRlIF92YWx1ZTtcbiAgICBwcml2YXRlIF9mb3JtYXR0ZWRWYWx1ZVN0cmluZztcbiAgICBwcml2YXRlIF9za2lwVmFsdWVDaGFuZ2VFbWlzc2lvbjtcbiAgICBzZXQgdmFsdWUodmFsdWU6IERhdGUpO1xuICAgIGdldCB2YWx1ZSgpOiBEYXRlO1xuICAgIGdldCBpc1BtKCk6IGJvb2xlYW47XG4gICAgZ2V0IGVtcHR5KCk6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBnZXQgZm9ybWF0dGVkVmFsdWVTdHJpbmcoKTtcbiAgICBwcml2YXRlIGN1cnJlbnRWYWx1ZTtcbiAgICBwcml2YXRlIG1vZGFsUmVmO1xuICAgIHByaXZhdGUgb25DaGFuZ2VGbjtcbiAgICBwcml2YXRlIG9uVG91Y2hlZEZuO1xuICAgIHByaXZhdGUgY29tYmluYXRpb247XG4gICAgdGltZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgaW52YWxpZElucHV0OiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBpbnB1dEhhbmRsZXIoKTogdm9pZDtcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogYW55KTogYm9vbGVhbjtcbiAgICBrZXl1cEhhbmRsZXIoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgZm9jdXNIYW5kbGVyKCk6IHZvaWQ7XG4gICAgZm9jdXNvdXRIYW5kbGVyKCk6IHZvaWQ7XG4gICAgY29uc3RydWN0b3IobmdDb250cm9sOiBOZ0NvbnRyb2wsIGRpYWxvZzogTWF0RGlhbG9nLCByZW5kZXJlcjogUmVuZGVyZXIyLCB6b25lOiBOZ1pvbmUsIGZtOiBGb2N1c01vbml0b3IsIGVsUmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Piwgbmdab25lOiBOZ1pvbmUsIF9wbGF0Zm9ybTogUGxhdGZvcm0sIF9wYXJlbnRGb3JtOiBOZ0Zvcm0sIF9tYXRGb3JtRmlsZWQ6IE1hdEZvcm1GaWVsZCwgX3BhcmVudEZvcm1Hcm91cDogRm9ybUdyb3VwRGlyZWN0aXZlLCBfZGVmYXVsdEVycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcik7XG4gICAgc2V0RGVzY3JpYmVkQnlJZHMoaWRzOiBzdHJpbmdbXSk6IHZvaWQ7XG4gICAgb25Db250YWluZXJDbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQ7XG4gICAgc2V0SW5wdXRFbGVtZW50VmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgdmFsaWRhdGUoKToge1xuICAgICAgICBkYXRlUmFuZ2U6IGJvb2xlYW47XG4gICAgfTtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICBjbGlja0hhbmRsZXI6IChlOiBGb2N1c0V2ZW50KSA9PiB2b2lkO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgZ2VuZXJhdGVBbGxvd2VkTWFwKCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoc2ltcGxlQ2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgY2hlY2tWYWxpZGl0eSh2YWx1ZTogRGF0ZSk6IGJvb2xlYW47XG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogRGF0ZSwgaXNJbm5lckNhbGw/OiBib29sZWFuKTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkO1xuICAgIHNldERpc2FibGVkU3RhdGU/KGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIHNob3dEaWFsb2coKTogdm9pZDtcbiAgICBoYW5kbGVDaGFuZ2U6IChuZXdWYWx1ZTogYW55KSA9PiB2b2lkO1xuICAgIGhhbmRsZU9rOiAodmFsdWU6IGFueSkgPT4gdm9pZDtcbiAgICBoYW5kbGVDYW5jZWw6ICgpID0+IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbn1cbiJdfQ==