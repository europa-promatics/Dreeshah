(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/forms'), require('@angular/core'), require('@angular/material/dialog'), require('@angular/material/form-field'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/a11y'), require('@angular/cdk/coercion'), require('@angular/material/core'), require('@angular/cdk/platform'), require('@angular/material/button'), require('@angular/material/toolbar'), require('@angular/material/icon'), require('@angular/material/input'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('mat-timepicker', ['exports', '@angular/forms', '@angular/core', '@angular/material/dialog', '@angular/material/form-field', 'rxjs', 'rxjs/operators', '@angular/cdk/a11y', '@angular/cdk/coercion', '@angular/material/core', '@angular/cdk/platform', '@angular/material/button', '@angular/material/toolbar', '@angular/material/icon', '@angular/material/input', '@angular/common'], factory) :
    (global = global || self, factory(global['mat-timepicker'] = {}, global.ng.forms, global.ng.core, global.ng.material.dialog, global.ng.material.formField, global.rxjs, global.rxjs.operators, global.ng.cdk.a11y, global.ng.cdk.coercion, global.ng.material.core, global.ng.cdk.platform, global.ng.material.button, global.ng.material.toolbar, global.ng.material.icon, global.ng.material.input, global.ng.common));
}(this, (function (exports, forms, core, dialog, formField, rxjs, operators, a11y, coercion, core$1, platform, button, toolbar, icon, input, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, exports) {
        for (var p in m)
            if (p !== "default" && !exports.hasOwnProperty(p))
                __createBinding(exports, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    function twoDigits(n) {
        return n < 10 ? "0" + n : "" + n;
    }
    function addDays(date, days) {
        var result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    }
    function convertHoursForMode(hour, mode) {
        var isPm = hour >= 12;
        if (mode === '24h') {
            return { hour: hour, isPm: isPm };
        }
        else if (hour === 0 || hour === 12) {
            return { hour: 12, isPm: isPm };
        }
        else if (hour < 12) {
            return { hour: hour, isPm: isPm };
        }
        return { hour: hour - 12, isPm: isPm };
    }
    function mod(a, b) {
        return a - Math.floor(a / b) * b;
    }
    function getShortestAngle(from, to) {
        var difference = to - from;
        return from + mod(difference + 180, 360) - 180;
    }
    function isDateInRange(minDate, maxDate, current) {
        var unixCurrentDate = +current;
        return (!minDate || +minDate <= unixCurrentDate) && (!maxDate || unixCurrentDate <= +maxDate);
    }
    function isTimeInRange(minDate, maxDate, current) {
        if (minDate instanceof Date) {
            var newMinDate = new Date();
            newMinDate.setHours(minDate.getHours());
            newMinDate.setMinutes(minDate.getMinutes());
            newMinDate.setSeconds(0);
            newMinDate.setMilliseconds(0);
            minDate = newMinDate;
        }
        if (maxDate instanceof Date) {
            var newMaxDate = new Date();
            newMaxDate.setHours(maxDate.getHours());
            newMaxDate.setMinutes(maxDate.getMinutes());
            newMaxDate.setSeconds(0);
            newMaxDate.setMilliseconds(0);
            maxDate = newMaxDate;
        }
        if (current instanceof Date) {
            var newCurrent = new Date();
            newCurrent.setHours(current.getHours());
            newCurrent.setMinutes(current.getMinutes());
            newCurrent.setSeconds(0);
            newCurrent.setMilliseconds(0);
            current = newCurrent;
        }
        var unixCurrentDate = +current;
        return (!minDate || +minDate <= unixCurrentDate) && (!maxDate || unixCurrentDate <= +maxDate);
    }
    // used when generating the allowed maps
    function isAllowed(hour, minutes, minDate, maxDate, clockMode, selectedMeridiem) {
        if (hour > 24 || hour < 0 || minutes > 60 || minutes < 0) {
            return false;
        }
        if (!minDate && !maxDate) {
            return true;
        }
        if (clockMode === '12h') {
            if (hour === 12 && selectedMeridiem === 'AM') {
                hour = 0;
            }
            if (hour > 12) {
                hour -= 12;
            }
        }
        var checkDate = new Date();
        checkDate.setHours(hour);
        checkDate.setMinutes(minutes);
        checkDate.setSeconds(0);
        checkDate.setMilliseconds(0);
        return isDateInRange(minDate, maxDate, checkDate);
    }
    // used by the clock component to visually disable the not allowed values
    function getIsAvailabeFn(allowed12HourMap, allowed24HourMap, mode) {
        return function (value, viewType, isPm, h) {
            var isHourCheck = viewType === 'hours';
            var _a = __read(isHourCheck ? [value, null] : [h, value], 2), hour = _a[0], minutes = _a[1];
            if (mode === '12h') {
                if (!allowed12HourMap) {
                    return true;
                }
                var meridiem = isPm ? 'pm' : 'am';
                if (isHourCheck) {
                    return !!Object.values(allowed12HourMap[meridiem][hour]).find(function (v) { return v === true; });
                }
                return allowed12HourMap[meridiem][hour][minutes];
            }
            if (!allowed24HourMap) {
                return true;
            }
            if (isHourCheck) {
                return !!Object.values(allowed24HourMap[hour]).find(function (v) { return v === true; });
            }
            return allowed24HourMap[hour][minutes];
        };
    }

    var MatTimepickerComponentDialogComponent = /** @class */ (function () {
        function MatTimepickerComponentDialogComponent(data) {
            var _this = this;
            this.data = data;
            this.twoDigits = twoDigits;
            this.changeEvent = new core.EventEmitter();
            this.okClickEvent = new core.EventEmitter();
            this.cancelClickEvent = new core.EventEmitter();
            this.allowed24HourMap = null;
            this.allowed12HourMap = null;
            this.invalidSelection = false;
            this.viewType = 'hours';
            this.isPm = false;
            this.skipMinuteAutoSwitch = false;
            this.autoSwitchID = null;
            this.invalidMedianID = null;
            this.hasInvalidMeridiem = false;
            this.editHoursClicked = false;
            this.isClosing = false;
            this.okClickHandler = function () {
                if (_this.hasInvalidMeridiem) {
                    _this.isPm = !_this.isPm;
                    _this.hasInvalidMeridiem = false;
                }
                _this.okClickEvent.emit(_this.value);
            };
            this.cancelClickHandler = function () {
                _this.cancelClickEvent.emit();
            };
            this.isPm = data.isPm;
            this.bindData(data);
            // keep this always at the bottom
            this.value = data.value;
        }
        Object.defineProperty(MatTimepickerComponentDialogComponent.prototype, "value", {
            get: function () { return this._value; },
            set: function (value) {
                value = value || this.minDate || this.maxDate || new Date();
                this.hours = value.getHours();
                this.minutes = value.getMinutes();
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerComponentDialogComponent.prototype, "hours", {
            get: function () { return this._hours; },
            set: function (value) {
                this._hours = value;
                this._formattedHour = convertHoursForMode(this.hours, this.mode).hour;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerComponentDialogComponent.prototype, "formattedHours", {
            get: function () { return this._formattedHour; },
            enumerable: false,
            configurable: true
        });
        MatTimepickerComponentDialogComponent.prototype.bindData = function (data) {
            this.mode = data.mode;
            this.okLabel = data.okLabel;
            this.cancelLabel = data.cancelLabel;
            this.okButtonTemplate = data.okButtonTemplate;
            this.cancelButtonTemplate = data.cancelButtonTemplate;
            this.anteMeridiemAbbreviation = data.anteMeridiemAbbreviation;
            this.postMeridiemAbbreviation = data.postMeridiemAbbreviation;
            this.color = data.color;
            this.minDate = data.minDate;
            this.maxDate = data.maxDate;
            this.allowed12HourMap = data.allowed12HourMap;
            this.allowed24HourMap = data.allowed24HourMap;
        };
        MatTimepickerComponentDialogComponent.prototype.ngDoCheck = function () { this.bindData(this.data); };
        MatTimepickerComponentDialogComponent.prototype.handleClockChange = function (_a) {
            var value = _a.value, type = _a.type;
            var is24hoursAutoMeridiemChange = this.mode === '24h' && type === 'hours' && ((this.hours >= 12 && value < 12) || (this.hours < 12 && value >= 12));
            if ((this.hasInvalidMeridiem && this.mode === '12h') || is24hoursAutoMeridiemChange) {
                this.isPm = !this.isPm;
                this.hasInvalidMeridiem = false;
            }
            if ((type && type === 'hours') || (!type && this.viewType === 'hours')) {
                this.hours = value;
            }
            else if ((type && type === 'minutes') || (!type && this.viewType === 'minutes')) {
                this.minutes = value;
            }
            var newValue = new Date();
            var hours = this.isPm ? this.hours < 12 ? this.hours + 12 : this.hours : this.hours === 12 ? 0 : this.hours;
            newValue.setHours(hours);
            newValue.setMinutes(this.minutes);
            newValue.setSeconds(0);
            newValue.setMilliseconds(0);
            this.value = newValue;
            this.changeEvent.emit(newValue);
        };
        MatTimepickerComponentDialogComponent.prototype.clearInvalidMeridiem = function () {
            this.hasInvalidMeridiem = false;
        };
        MatTimepickerComponentDialogComponent.prototype.handleUnavailableSelection = function () {
            clearTimeout(this.autoSwitchID);
        };
        MatTimepickerComponentDialogComponent.prototype.handleClockChangeDone = function (e) {
            var _this = this;
            e.preventDefault(); // prevent mouseUp after touchEnd
            if (this.viewType === 'hours' && !this.skipMinuteAutoSwitch) {
                this.autoSwitchID = setTimeout(function () {
                    _this.editMinutes();
                    _this.autoSwitchID = null;
                }, 300);
            }
        };
        MatTimepickerComponentDialogComponent.prototype.editHours = function () {
            var _this = this;
            this.viewType = 'hours';
            this.editHoursClicked = true;
            setTimeout(function () { _this.editHoursClicked = false; }, 0);
        };
        MatTimepickerComponentDialogComponent.prototype.editMinutes = function () {
            if (this.hasInvalidMeridiem) {
                this.isPm = !this.isPm;
                this.hasInvalidMeridiem = false;
            }
            this.viewType = 'minutes';
        };
        MatTimepickerComponentDialogComponent.prototype.invalidSelectionHandler = function (value) {
            this.invalidSelection = value;
        };
        MatTimepickerComponentDialogComponent.prototype.invalidMeridiem = function () {
            var _this = this;
            if (this.viewType !== 'minutes' && this.editHoursClicked) {
                if (this.invalidMedianID) {
                    return;
                }
                this.invalidMedianID = setTimeout(function () {
                    _this.isPm = !_this.isPm;
                    _this.hasInvalidMeridiem = false;
                }, 0);
                return;
            }
            this.hasInvalidMeridiem = true;
        };
        MatTimepickerComponentDialogComponent.prototype.meridiemChange = function (hours) {
            var changeData = {
                type: this.viewType,
                value: this.viewType === 'hours' ? hours : this.value.getMinutes()
            };
            this.handleClockChange(changeData);
        };
        MatTimepickerComponentDialogComponent.prototype.setAm = function () {
            if (this.hours >= 12) {
                this.hours = this.hours - 12;
            }
            this.isPm = false;
            this.meridiemChange(this.hours);
        };
        MatTimepickerComponentDialogComponent.prototype.setPm = function () {
            if (this.hours < 12) {
                this.hours = this.hours + 12;
            }
            this.isPm = true;
            this.meridiemChange(this.hours);
        };
        return MatTimepickerComponentDialogComponent;
    }());
    MatTimepickerComponentDialogComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mat-timepicker-dialog',
                    template: "<ng-template #defaultCancelButtonTemplate>\n  <button mat-button [color]=\"color\" (click)=\"cancelClickHandler()\">{{cancelLabel}}</button>\n</ng-template>\n<ng-template #defaultOkButtonTemplate>\n  <button mat-button [disabled]=\"invalidSelection\" [color]=\"color\" (click)=\"okClickHandler()\">{{okLabel}}</button>\n</ng-template>\n\n<mat-dialog-content>\n  <div class=\"root\">\n    <mat-toolbar [color]=\"color\" class=\"header\">\n      <div class=\"placeholder\"></div>\n      <div class=\"time-frame\">\n        <span class=\"time fixed-font-size\" [ngClass]=\"{'select': this.viewType === 'hours' && 'active' }\"\n          (click)=\"editHours()\">\n          {{ twoDigits(formattedHours) }}\n        </span>\n        <span class=\"fixed-font-size\">:</span>\n        <span class=\"time fixed-font-size\" [ngClass]=\"{ 'select': this.viewType === 'minutes' && 'active' }\"\n          (click)=\"editMinutes()\">\n          {{ twoDigits(minutes) }}\n        </span>\n      </div>\n      <ng-container *ngIf=\"mode === '12h' then ampm else normal\"></ng-container>\n      <ng-template #normal>\n        <div class=\"placeholder\"></div>\n      </ng-template>\n      <ng-template #ampm>\n        <div class=\"ampm\">\n          <span class=\"time\" [ngClass]=\"{ 'select': isPm }\"\n            (click)=\"setPm()\">{{postMeridiemAbbreviation | uppercase }}</span>\n          <span class=\"time\" [ngClass]=\"{ 'select': !isPm }\"\n            (click)=\"setAm()\">{{anteMeridiemAbbreviation | uppercase }}</span>\n        </div>\n      </ng-template>\n    </mat-toolbar>\n    <div class=\"body\">\n      <mat-clock [allowed12HourMap]=\"allowed12HourMap\" [allowed24HourMap]=\"allowed24HourMap\" [minDate]=\"minDate\"\n        [maxDate]=\"maxDate\" [color]=\"color\" [viewType]=\"viewType\" [mode]=\"mode\" [formattedHours]=\"formattedHours\"\n        [minutes]=\"minutes\" (changeEvent)=\"handleClockChange($event)\"\n        (unavailableSelection)=\"handleUnavailableSelection()\"\n        [formattedValue]=\"viewType === 'minutes' ? minutes : formattedHours\" [isPm]=\"isPm\"\n        (invalidMeridiem)=\"invalidMeridiem()\" (mouseup)=\"handleClockChangeDone($event)\"\n        (clearInvalidMeridiem)=\"clearInvalidMeridiem()\" (touchend)=\"handleClockChangeDone($event)\"\n        (invalidSelection)=\"invalidSelectionHandler($event)\"></mat-clock>\n    </div>\n  </div>\n</mat-dialog-content>\n<mat-dialog-actions>\n  <ng-container\n    *ngTemplateOutlet=\"cancelButtonTemplate || defaultCancelButtonTemplate; context: { label: cancelLabel, $implicit: cancelClickHandler }\">\n  </ng-container>\n  <ng-container\n    *ngTemplateOutlet=\"okButtonTemplate || defaultOkButtonTemplate; context: { label: okLabel, $implicit: okClickHandler }\">\n  </ng-container>\n</mat-dialog-actions>",
                    styles: ["mat-dialog-content{margin-top:-24px;min-height:395px;overflow:hidden;padding:0}mat-dialog-actions{justify-content:flex-end;margin-left:-8px;margin-right:-8px}.root{min-width:282px}.header{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;align-items:center;border-top-left-radius:2px;border-top-right-radius:2px;display:flex;height:98px;justify-content:center;line-height:58px;padding:20px 0;user-select:none}.header,.header .fixed-font-size{font-size:58px}.header .time-frame{height:60px}.time{cursor:pointer;transition:all .2s ease-out}.time:not(.select){opacity:.6}.placeholder{flex:1}.ampm{display:flex;flex:1;flex-direction:column-reverse;font-size:14px;font-weight:700px;line-height:20px;margin-left:16px}.select{color:#fff}.body{display:flex;justify-content:center;padding:24px 16px 20px}"]
                },] }
    ];
    MatTimepickerComponentDialogComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [dialog.MAT_DIALOG_DATA,] }] }
    ]; };
    MatTimepickerComponentDialogComponent.propDecorators = {
        changeEvent: [{ type: core.Output }],
        okClickEvent: [{ type: core.Output }],
        cancelClickEvent: [{ type: core.Output }]
    };

    var MatTimepickerDirective = /** @class */ (function () {
        function MatTimepickerDirective(ngControl, dialog, renderer, zone, fm, elRef, ngZone, 
        // tslint:disable-next-line:variable-name
        _platform, 
        // tslint:disable-next-line:variable-name
        _parentForm, 
        // tslint:disable-next-line:variable-name
        _matFormFiled, 
        // tslint:disable-next-line:variable-name
        _parentFormGroup, 
        // tslint:disable-next-line:variable-name
        _defaultErrorStateMatcher) {
            var _this = this;
            this.ngControl = ngControl;
            this.dialog = dialog;
            this.renderer = renderer;
            this.zone = zone;
            this.fm = fm;
            this.elRef = elRef;
            this.ngZone = ngZone;
            this._platform = _platform;
            this._parentForm = _parentForm;
            this._matFormFiled = _matFormFiled;
            this._parentFormGroup = _parentFormGroup;
            // tslint:disable-next-line:variable-name
            this._errorState = false;
            // tslint:disable-next-line:variable-name
            this._disabled = false;
            // tslint:disable-next-line:variable-name
            this._readonly = false;
            this.isAlive = new rxjs.Subject();
            this.stateChanges = new rxjs.Subject();
            // tslint:disable-next-line:variable-name
            this._uid = "mat-input-" + MatTimepickerDirective.nextId++;
            this.describedBy = '';
            // tslint:disable-next-line:variable-name
            this._required = false;
            this.focused = false;
            this.allowed24HourMap = null;
            this.allowed12HourMap = null;
            this.isInputFocused = false;
            /* Use a custom template for the ok button */
            this.okButtonTemplate = null;
            /* Use a custom template for the cancel button */
            this.cancelButtonTemplate = null;
            /** Override the label of the ok button. */
            this.okLabel = 'Ok';
            /** Override the label of the cancel button. */
            this.cancelLabel = 'Cancel';
            /** Override the ante meridiem abbreviation. */
            this.anteMeridiemAbbreviation = 'am';
            /** Override the post meridiem abbreviation. */
            this.postMeridiemAbbreviation = 'pm';
            /** Sets the clock mode, 12-hour or 24-hour clocks are supported. */
            this.mode = '24h';
            this.color = 'primary';
            this.disableDialogOpenOnClick = false;
            this.strict = true;
            this.controlType = 'angular-material-timepicker';
            this.listeners = [];
            // tslint:disable-next-line:variable-name
            this._skipValueChangeEmission = true;
            this.combination = [];
            this.timeChange = new core.EventEmitter();
            this.invalidInput = new core.EventEmitter();
            this.clickHandler = function (e) {
                if ((_this.modalRef && _this.modalRef.componentInstance.isClosing) || _this.disabled || _this.disableDialogOpenOnClick) {
                    return;
                }
                if (!_this.modalRef && !_this.disableDialogOpenOnClick) {
                    _this.showDialog();
                }
            };
            this.handleChange = function (newValue) {
                if (!(newValue instanceof Date)) {
                    return;
                }
                var v = _this.value instanceof Date ? new Date(_this.value.getTime()) : new Date();
                v.setHours(newValue.getHours());
                v.setMinutes(newValue.getMinutes());
                v.setSeconds(0);
                v.setMilliseconds(0);
                _this.currentValue = v;
            };
            this.handleOk = function (value) {
                if (!_this.currentValue && value) {
                    _this.currentValue = value;
                }
                if (_this.onChangeFn) {
                    _this.onChangeFn(_this.currentValue);
                }
                _this.value = _this.currentValue;
                _this.modalRef.close();
            };
            this.handleCancel = function () {
                _this.modalRef.close();
            };
            this.id = this.id;
            this.errorStateMatcher = _defaultErrorStateMatcher;
            if (this.ngControl != null) {
                this.ngControl.valueAccessor = this;
            }
            if (_platform.IOS) {
                ngZone.runOutsideAngular(function () {
                    elRef.nativeElement.addEventListener('keyup', function (event) {
                        var el = event.target;
                        if (!el.value && !el.selectionStart && !el.selectionEnd) {
                            // Note: Just setting `0, 0` doesn't fix the issue. Setting
                            // `1, 1` fixes it for the first time that you type text and
                            // then hold delete. Toggling to `1, 1` and then back to
                            // `0, 0` seems to completely fix it.
                            el.setSelectionRange(1, 1);
                            el.setSelectionRange(0, 0);
                        }
                    });
                });
            }
            this._isServer = !this._platform.isBrowser;
        }
        Object.defineProperty(MatTimepickerDirective.prototype, "errorState", {
            get: function () {
                var oldState = this._errorState;
                var parent = this._parentFormGroup || this._parentForm;
                var control = this.ngControl ? this.ngControl.control : null;
                var newState = this.errorStateMatcher ? this.errorStateMatcher.isErrorState(control, parent) : oldState;
                if (newState !== oldState) {
                    this._errorState = newState;
                    this.stateChanges.next();
                }
                return newState;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "disabled", {
            get: function () {
                if (this.ngControl && this.ngControl.disabled !== null) {
                    return this.ngControl.disabled;
                }
                return this._disabled;
            },
            set: function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                // Browsers may not fire the blur event if the input is disabled too quickly.
                // Reset from here to ensure that the element doesn't become stuck.
                if (this.focused) {
                    this.focused = false;
                    this.stateChanges.next();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "id", {
            get: function () { return this._id; },
            set: function (value) { this._id = value || this._uid; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "readonly", {
            get: function () { return this._readonly; },
            set: function (value) { this._readonly = coercion.coerceBooleanProperty(value); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "shouldLabelFloat", {
            get: function () { return this.focused || !this.empty; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "required", {
            get: function () {
                return this._required;
            },
            set: function (req) {
                this._required = coercion.coerceBooleanProperty(req);
                this.stateChanges.next();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            set: function (plh) {
                this._placeholder = plh;
                this.stateChanges.next();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "value", {
            get: function () { return this._value; },
            set: function (value) {
                if (value === this._value) {
                    return;
                }
                this._value = value;
                if (!value) {
                    this._formattedValueString = null;
                    this.setInputElementValue('');
                    this.currentValue = value;
                    return;
                }
                var _a = convertHoursForMode(value.getHours(), this.mode), hour = _a.hour, isPm = _a.isPm;
                this._isPm = isPm;
                this._formattedValueString = this.mode === '12h' ?
                    hour + ":" + twoDigits(value.getMinutes()) + " " + (isPm ? this.postMeridiemAbbreviation : this.anteMeridiemAbbreviation) :
                    twoDigits(value.getHours()) + ":" + twoDigits(value.getMinutes());
                if (!this.isInputFocused) {
                    this.setInputElementValue(this.formattedValueString);
                }
                this.currentValue = value;
                this.stateChanges.next();
                if (this._skipValueChangeEmission) {
                    return;
                }
                this.timeChange.emit(this.currentValue);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "isPm", {
            get: function () { return this._isPm; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "empty", {
            get: function () {
                return !(this.currentValue instanceof Date);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatTimepickerDirective.prototype, "formattedValueString", {
            get: function () { return this._formattedValueString; },
            enumerable: false,
            configurable: true
        });
        MatTimepickerDirective.prototype.inputHandler = function () {
            var _a, _b;
            var value = this.elRef.nativeElement.value;
            var length = value.length;
            if (length === 0) {
                this.writeValue(null, true);
                if (this.onChangeFn) {
                    this.onChangeFn(null);
                }
                return;
            }
            var meridiemResult = value.match(/am|pm/i);
            var meridiem = null;
            if (meridiemResult) {
                value = value.replace(meridiemResult[0], '');
                _a = __read(meridiemResult, 1), meridiem = _a[0];
            }
            var valueHasColumn = value.includes(':');
            var _c = __read(length === 1 ? [value, 0] :
                length === 2 && !valueHasColumn ? [value, 0] : valueHasColumn ? value.split(':') : value.split(/(\d\d)/).filter(function (v) { return v; }), 2), hours = _c[0], minutes = _c[1];
            hours = +hours;
            if (/\s/.test(minutes)) {
                var other = void 0;
                _b = __read(minutes.split(/\s/), 2), minutes = _b[0], other = _b[1];
                if (other === 'pm' && !isNaN(hours) && hours < 12) {
                    hours += 12;
                }
            }
            minutes = +minutes;
            if (isNaN(hours) || isNaN(minutes)) {
                this.writeValue(null, true);
                return;
            }
            if (hours < 12 && meridiem && meridiem.toLowerCase() === 'pm') {
                hours += 12;
            }
            else if (hours > 12 && meridiem && meridiem.toLowerCase() === 'am') {
                hours -= 12;
            }
            if (this.mode === '12h' && +hours < 1) {
                hours = '1';
            }
            else {
                if (+hours > 24) {
                    hours = '24';
                }
                else if (+hours < 0) {
                    hours = '0';
                }
            }
            if (+minutes > 59) {
                minutes = '59';
            }
            else if (+minutes < 0) {
                minutes = '0';
            }
            var d = this.value ? new Date(this.value.getTime()) : new Date();
            d.setHours(+hours);
            d.setMinutes(+minutes);
            d.setSeconds(0);
            d.setMilliseconds(0);
            var isValueInRange = isDateInRange(this.minDate, this.maxDate, d);
            if (!isValueInRange) {
                this.invalidInput.emit();
            }
            this.writeValue(d, true);
            if (this.onChangeFn) {
                this.onChangeFn(d);
            }
        };
        MatTimepickerDirective.prototype.keydownHandler = function (event) {
            if (event.metaKey || event.ctrlKey || event.altKey) {
                this.combination = this.combination.concat(event.code);
                return;
            }
            if (!/^[0-9a-zA-Z\s]{0,1}$/.test(event.key)) {
                return;
            }
            var target = event.target;
            var tValue = target.value;
            var value = "" + tValue.slice(0, target.selectionStart) + event.key + tValue.slice(target.selectionEnd);
            if (value.match(this.pattern) || this.combination.length > 0) {
                return true;
            }
            event.preventDefault();
            event.stopImmediatePropagation();
        };
        MatTimepickerDirective.prototype.keyupHandler = function (event) {
            this.combination = this.combination.filter(function (v) { return v !== event.code; });
        };
        MatTimepickerDirective.prototype.focusHandler = function () {
            this.isInputFocused = true;
        };
        MatTimepickerDirective.prototype.focusoutHandler = function () {
            this.isInputFocused = false;
            this.setInputElementValue(this.formattedValueString);
            if (this.onTouchedFn && !this.modalRef) {
                this.onTouchedFn();
            }
        };
        MatTimepickerDirective.prototype.setDescribedByIds = function (ids) {
            this.describedBy = ids.join(' ');
        };
        MatTimepickerDirective.prototype.onContainerClick = function (event) {
            if (event.target.tagName.toLowerCase() !== 'input') {
                this.elRef.nativeElement.focus();
            }
        };
        MatTimepickerDirective.prototype.setInputElementValue = function (value) {
            var _this = this;
            if (value === null || value === undefined) {
                value = '';
            }
            Promise.resolve().then(function () {
                _this.zone.runOutsideAngular(function () {
                    _this.renderer.setProperty(_this.elRef.nativeElement, 'value', value);
                });
            });
        };
        MatTimepickerDirective.prototype.validate = function () {
            if (this.currentValue === null || this.currentValue === undefined) {
                return null;
            }
            var isValueInRange = this.strict ?
                isDateInRange(this.minDate, this.maxDate, this.currentValue) :
                isTimeInRange(this.minDate, this.maxDate, this.currentValue);
            return isValueInRange ? null : { dateRange: true };
        };
        MatTimepickerDirective.prototype.ngAfterViewInit = function () {
            this.listeners.push(this.renderer.listen(this._matFormFiled ? this._matFormFiled._elementRef.nativeElement : this.elRef.nativeElement, 'click', this.clickHandler));
        };
        MatTimepickerDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this._platform.isBrowser) {
                this.fm.monitor(this.elRef.nativeElement, true).subscribe(function (origin) {
                    _this.focused = !!origin;
                    _this.stateChanges.next();
                });
            }
            var hasMaxDate = !!this.maxDate;
            var hasMinDate = !!this.minDate;
            if (hasMinDate || hasMaxDate) {
                if (hasMinDate) {
                    this.minDate.setSeconds(0);
                    this.minDate.setMilliseconds(0);
                }
                if (hasMaxDate) {
                    this.maxDate.setSeconds(0);
                    this.maxDate.setMilliseconds(0);
                }
                Promise.resolve().then(function () { return _this.generateAllowedMap(); });
                if (!this.ngControl._rawValidators.find(function (v) { return v === _this; })) {
                    this.ngControl.control.setValidators(this.ngControl._rawValidators.concat(this));
                    this.ngControl.control.updateValueAndValidity();
                }
            }
            this._skipValueChangeEmission = false;
        };
        MatTimepickerDirective.prototype.generateAllowedMap = function () {
            var isStrictMode = this.strict && this.value instanceof Date;
            if (this.mode === '24h') {
                this.allowed24HourMap = {};
                for (var h = 0; h < 24; h++) {
                    for (var m = 0; m < 60; m++) {
                        var hourMap = this.allowed24HourMap[h] || {};
                        if (isStrictMode) {
                            var currentDate = new Date(this.value.getTime());
                            currentDate.setHours(h);
                            currentDate.setMinutes(m);
                            currentDate.setSeconds(0);
                            currentDate.setMilliseconds(0);
                            hourMap[m] = isDateInRange(this.minDate, this.maxDate, currentDate);
                        }
                        else {
                            hourMap[m] = isAllowed(h, m, this.minDate, this.maxDate, '24h');
                        }
                        this.allowed24HourMap[h] = hourMap;
                    }
                }
            }
            else {
                this.allowed12HourMap = { am: {}, pm: {} };
                for (var h = 0; h < 24; h++) {
                    var meridiem = h < 12 ? 'am' : 'pm';
                    for (var m = 0; m < 60; m++) {
                        var hour = (h > 12 ? h - 12 : h === 0 ? 12 : h);
                        var hourMap = this.allowed12HourMap[meridiem][hour] || {};
                        if (isStrictMode) {
                            var currentDate = new Date(this.value.getTime());
                            currentDate.setHours(h);
                            currentDate.setMinutes(m);
                            currentDate.setSeconds(0);
                            currentDate.setMilliseconds(0);
                            hourMap[m] = isDateInRange(this.minDate, this.maxDate, currentDate);
                        }
                        else {
                            hourMap[m] = isAllowed(h, m, this.minDate, this.maxDate, '24h');
                        }
                        this.allowed12HourMap[meridiem][hour] = hourMap;
                    }
                }
            }
        };
        MatTimepickerDirective.prototype.ngOnChanges = function (simpleChanges) {
            this.pattern = this.mode === '24h' ? /^[0-9]{1,2}:?([0-9]{1,2})?$/ : /^[0-9]{1,2}:?([0-9]{1,2})?\s?(a|p)?m?$/;
            if ((simpleChanges.minDate && !simpleChanges.minDate.isFirstChange() &&
                +simpleChanges.minDate.currentValue !== simpleChanges.minDate.previousValue) ||
                (simpleChanges.maxDate && !simpleChanges.maxDate.isFirstChange() &&
                    +simpleChanges.maxDate.currentValue !== simpleChanges.maxDate.previousValue) ||
                (simpleChanges.disableLimitBase && !simpleChanges.disableLimitBase.isFirstChange() &&
                    +simpleChanges.disableLimitBase.currentValue !== simpleChanges.disableLimitBase.previousValue)) {
                this.generateAllowedMap();
                this.ngControl.control.updateValueAndValidity();
            }
            if (!this.modalRef || !this.modalRef.componentInstance) {
                return;
            }
            this.modalRef.componentInstance.data = {
                mode: this.mode,
                value: this.currentValue,
                okLabel: this.okLabel,
                cancelLabel: this.cancelLabel,
                okButtonTemplate: this.okButtonTemplate,
                cancelButtonTemplate: this.cancelButtonTemplate,
                anteMeridiemAbbreviation: this.anteMeridiemAbbreviation,
                postMeridiemAbbreviation: this.postMeridiemAbbreviation,
                color: this.color,
                isPm: this.isPm,
                minDate: this.minDate,
                maxDate: this.maxDate,
                allowed12HourMap: this.allowed12HourMap,
                allowed24HourMap: this.allowed24HourMap,
            };
        };
        MatTimepickerDirective.prototype.checkValidity = function (value) {
            if (!value) {
                return false;
            }
            var hour = value.getHours();
            var minutes = value.getMinutes();
            var meridiem = this.isPm ? 'PM' : 'AM';
            return isAllowed(hour, minutes, this.minDate, this.maxDate, this.mode, meridiem);
        };
        MatTimepickerDirective.prototype.writeValue = function (value, isInnerCall) {
            var _this = this;
            if (isInnerCall === void 0) { isInnerCall = false; }
            if (!isInnerCall) {
                this._skipValueChangeEmission = true;
                Promise.resolve().then(function () { return _this._skipValueChangeEmission = false; });
            }
            if (value) {
                value.setSeconds(0);
                value.setMilliseconds(0);
            }
            if (+this.value !== +value) {
                this.value = value;
            }
        };
        MatTimepickerDirective.prototype.registerOnChange = function (fn) {
            this.onChangeFn = fn;
        };
        MatTimepickerDirective.prototype.registerOnTouched = function (fn) {
            this.onTouchedFn = fn;
        };
        MatTimepickerDirective.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        MatTimepickerDirective.prototype.showDialog = function () {
            var _this = this;
            if (this.disabled) {
                return;
            }
            this.isInputFocused = false;
            this.modalRef = this.dialog.open(MatTimepickerComponentDialogComponent, {
                autoFocus: false,
                data: {
                    mode: this.mode,
                    value: this.currentValue,
                    okLabel: this.okLabel,
                    cancelLabel: this.cancelLabel,
                    okButtonTemplate: this.okButtonTemplate,
                    cancelButtonTemplate: this.cancelButtonTemplate,
                    anteMeridiemAbbreviation: this.anteMeridiemAbbreviation,
                    postMeridiemAbbreviation: this.postMeridiemAbbreviation,
                    color: this.color,
                    isPm: this.isPm,
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                    allowed12HourMap: this.allowed12HourMap,
                    allowed24HourMap: this.allowed24HourMap
                }
            });
            var instance = this.modalRef.componentInstance;
            instance.changeEvent.pipe(operators.takeUntil(this.isAlive)).subscribe(this.handleChange);
            instance.okClickEvent.pipe(operators.takeUntil(this.isAlive)).subscribe(this.handleOk);
            instance.cancelClickEvent.pipe(operators.takeUntil(this.isAlive)).subscribe(this.handleCancel);
            this.modalRef.beforeClosed().pipe(operators.first()).subscribe(function () { return instance.isClosing = true; });
            this.modalRef.afterClosed().pipe(operators.first()).subscribe(function () {
                if (_this.onTouchedFn) {
                    _this.onTouchedFn();
                }
                _this.modalRef = null;
                _this.elRef.nativeElement.focus();
            });
            this.currentValue = this.value;
        };
        MatTimepickerDirective.prototype.ngOnDestroy = function () {
            this.isAlive.next();
            this.isAlive.complete();
            this.stateChanges.complete();
            if (this._platform.isBrowser) {
                this.fm.stopMonitoring(this.elRef.nativeElement);
            }
            this.listeners.forEach(function (l) { return l(); });
        };
        return MatTimepickerDirective;
    }());
    MatTimepickerDirective.nextId = 0;
    MatTimepickerDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: 'input[matTimepicker]',
                    providers: [
                        { provide: formField.MatFormFieldControl, useExisting: MatTimepickerDirective }
                    ],
                    // tslint:disable-next-line:no-host-metadata-property
                    host: {
                        /**
                         * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.
                         */
                        // tslint:disable-next-line:object-literal-key-quotes
                        'class': 'mat-input-element mat-form-field-autofill-control',
                        '[class.mat-input-server]': '_isServer',
                        // Native input properties that are overwritten by Angular inputs need to be synced with
                        // the native input element. Otherwise property bindings for those don't work.
                        '[attr.id]': 'id',
                        '[attr.placeholder]': 'placeholder',
                        '[disabled]': 'disabled',
                        '[required]': 'required',
                        '[attr.readonly]': 'readonly || null',
                        '[attr.aria-invalid]': 'errorState',
                        '[attr.aria-required]': 'required.toString()',
                    },
                    exportAs: 'matTimepicker'
                },] }
    ];
    MatTimepickerDirective.ctorParameters = function () { return [
        { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
        { type: dialog.MatDialog },
        { type: core.Renderer2 },
        { type: core.NgZone },
        { type: a11y.FocusMonitor },
        { type: core.ElementRef },
        { type: core.NgZone },
        { type: platform.Platform },
        { type: forms.NgForm, decorators: [{ type: core.Optional }] },
        { type: formField.MatFormField, decorators: [{ type: core.Optional }] },
        { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
        { type: core$1.ErrorStateMatcher }
    ]; };
    MatTimepickerDirective.propDecorators = {
        disabled: [{ type: core.Input }],
        id: [{ type: core.Input }],
        readonly: [{ type: core.Input }],
        shouldLabelFloat: [{ type: core.HostBinding, args: ['class.floating',] }],
        describedBy: [{ type: core.HostBinding, args: ['attr.aria-describedby',] }],
        errorStateMatcher: [{ type: core.Input }],
        required: [{ type: core.Input }],
        placeholder: [{ type: core.Input }],
        okButtonTemplate: [{ type: core.Input }],
        cancelButtonTemplate: [{ type: core.Input }],
        okLabel: [{ type: core.Input }],
        cancelLabel: [{ type: core.Input }],
        anteMeridiemAbbreviation: [{ type: core.Input }],
        postMeridiemAbbreviation: [{ type: core.Input }],
        mode: [{ type: core.Input }],
        color: [{ type: core.Input }],
        disableDialogOpenOnClick: [{ type: core.Input }],
        strict: [{ type: core.Input }],
        minDate: [{ type: core.Input }],
        maxDate: [{ type: core.Input }],
        value: [{ type: core.Input }],
        timeChange: [{ type: core.Output }],
        invalidInput: [{ type: core.Output }],
        inputHandler: [{ type: core.HostListener, args: ['input',] }],
        keydownHandler: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
        keyupHandler: [{ type: core.HostListener, args: ['keyup', ['$event'],] }],
        focusHandler: [{ type: core.HostListener, args: ['focus',] }],
        focusoutHandler: [{ type: core.HostListener, args: ['focusout',] }]
    };

    var ClockComponent = /** @class */ (function () {
        function ClockComponent() {
            var _this = this;
            this.color = 'primary';
            this.changeEvent = new core.EventEmitter();
            this.unavailableSelection = new core.EventEmitter();
            this.invalidMeridiem = new core.EventEmitter();
            this.invalidSelection = new core.EventEmitter();
            this.clearInvalidMeridiem = new core.EventEmitter();
            this.allowed12HourMap = null;
            this.allowed24HourMap = null;
            this.isFormattedValueAllowed = true;
            this.meridiem = null;
            this.touching = false;
            this.numbers = [];
            this.secondaryNumbers = [];
            this.minuteDots = [];
            this.invalidMeridiemEmitted = true;
            this.handleTouchMove = function (e) {
                e.preventDefault(); // prevent scrolling behind the clock on iOS
                var rect = e.target.getBoundingClientRect();
                _this.movePointer(e.changedTouches[0].clientX - rect.left, e.changedTouches[0].clientY - rect.top);
            };
        }
        ClockComponent.prototype.initIsAllowedFn = function () {
            if (!this.allowed12HourMap && !this.allowed24HourMap) {
                return;
            }
            this.isAvailableFn = getIsAvailabeFn(this.allowed12HourMap, this.allowed24HourMap, this.mode);
        };
        ClockComponent.prototype.isAvailable = function (value) {
            return this.isAvailableFn ? this.isAvailableFn(value, this.viewType, this.isPm, this.formattedHours) : true;
        };
        ClockComponent.prototype.ngOnChanges = function (simpleChanges) {
            if (simpleChanges.allowed12HourMap ||
                simpleChanges.allowed24HourMap ||
                (simpleChanges.mode && !simpleChanges.mode.firstChange)) {
                this.initIsAllowedFn();
            }
            this.calculateAngule();
            this.setNumbers();
            this.meridiem = this.isPm ? 'PM' : 'AM';
            if (simpleChanges.formattedValue && (this.allowed12HourMap || this.allowed24HourMap)) {
                this.isFormattedValueAllowed = this.isAvailable(this.formattedValue);
            }
            var isSelectedTimeAvailable = (this.isAvailableFn) ?
                // when calling isAvailableFn here we should always set the viewType to minutes because we want to check the hours and the minutes
                this.isAvailableFn(this.minutes, 'minutes', this.isPm, this.formattedHours) : true;
            // if (this.mode === '24h' && this.viewType === 'minutes' && this.isAvailableFn) {
            //   const areMinitesAvailable = this.isAvailableFn(this.minutes, 'minutes', this.isPm, this.formattedHours);
            //   if (!areMinitesAvailable) {
            //     if (this.minDate && this.minDate.getMinutes() > this.minutes) {
            //       setTimeout(() => { this.changeEvent.emit({ value: this.minDate.getMinutes(), type: 'minutes' }); });
            //     } else {
            //       setTimeout(() => { this.changeEvent.emit({ value: this.maxDate.getMinutes(), type: 'minutes' }); });
            //     }
            //   }
            // }
            if (isSelectedTimeAvailable && this.invalidMeridiemEmitted) {
                this.clearInvalidMeridiem.emit();
                this.invalidMeridiemEmitted = false;
            }
            this.invalidSelection.emit(!isSelectedTimeAvailable);
        };
        ClockComponent.prototype.calculateAngule = function () {
            this.angle = this.getPointerAngle(this.formattedValue, this.viewType);
        };
        ClockComponent.prototype.setNumbers = function () {
            var _this = this;
            if (this.viewType === 'hours') {
                if (this.mode === '12h') {
                    var meridiem_1 = this.isPm ? 'pm' : 'am';
                    var isAllowedFn = this.allowed12HourMap ? function (num) { return _this.allowed12HourMap[meridiem_1][num + 1][0]; } : undefined;
                    this.numbers = this.getNumbers(12, { size: 256 }, isAllowedFn);
                    this.secondaryNumbers = [];
                    this.minuteDots = [];
                }
                else if (this.mode === '24h') {
                    var isAllowedFn = this.allowed24HourMap ? function (num) { return _this.allowed24HourMap[num][0]; } : undefined;
                    this.numbers = this.getNumbers(12, { size: 256 }, isAllowedFn);
                    this.secondaryNumbers = this.getNumbers(12, { size: 256 - 64, start: 13 }, isAllowedFn);
                    this.minuteDots = [];
                }
            }
            else {
                var meridiem_2 = this.isPm ? 'pm' : 'am';
                var isAllowedFn_1 = !!this.allowed12HourMap ? function (num) { return _this.allowed12HourMap[meridiem_2][_this.formattedHours][num]; } :
                    !!this.allowed24HourMap ? function (num) { return _this.allowed24HourMap[_this.formattedHours][num]; } : undefined;
                this.numbers = this.getNumbers(12, { size: 256, start: 5, step: 5 }, isAllowedFn_1);
                this.minuteDots = this.getNumbers(60, { size: 256, start: 13 }).map(function (digit) {
                    if (digit.display <= 59) {
                        digit.allowed = isAllowedFn_1 ? isAllowedFn_1(digit.display) : true;
                        return digit;
                    }
                    digit.display = digit.display - 60;
                    digit.allowed = isAllowedFn_1 ? isAllowedFn_1(digit.display) : true;
                    return digit;
                });
                this.secondaryNumbers = [];
            }
        };
        ClockComponent.prototype.disableAnimatedPointer = function () {
            this.touching = true;
        };
        ClockComponent.prototype.enableAnimatedPointer = function () {
            this.touching = false;
        };
        ClockComponent.prototype.handleTouchEnd = function (e) {
            this.handleTouchMove(e);
            this.enableAnimatedPointer();
        };
        ClockComponent.prototype.handleMouseMove = function (e) {
            // MouseEvent.which is deprecated, but MouseEvent.buttons is not supported in Safari
            if ((e.buttons === 1 || e.which === 1) && this.touching) {
                var rect = e.target.getBoundingClientRect();
                this.movePointer(e.clientX - rect.left, e.clientY - rect.top);
            }
        };
        ClockComponent.prototype.handleClick = function (e) {
            var rect = e.target.getBoundingClientRect();
            this.movePointer(e.clientX - rect.left, e.clientY - rect.top);
        };
        ClockComponent.prototype.movePointer = function (x, y) {
            var value = this.getPointerValue(x, y, 256);
            if (!this.isAvailable(value)) {
                this.unavailableSelection.emit();
                return;
            }
            if (value !== this.formattedValue) {
                this.changeEvent.emit({ value: value, type: this.viewType });
                if (this.viewType !== 'minutes') {
                    if (!this.isAvailable(value)) {
                        if (this.minDate && this.isAvailable(value)) {
                            this.changeEvent.emit({ value: this.minDate.getMinutes(), type: 'minutes' });
                        }
                        else if (this.maxDate && this.isAvailable(value)) {
                            this.changeEvent.emit({ value: this.maxDate.getMinutes(), type: 'minutes' });
                        }
                    }
                }
            }
        };
        ClockComponent.prototype.getNumbers = function (count, _a, isAllowedFn) {
            var size = _a.size, _b = _a.start, start = _b === void 0 ? 1 : _b, _c = _a.step, step = _c === void 0 ? 1 : _c;
            return Array.apply(null, Array(count)).map(function (_, i) { return ({
                display: i * step + start,
                translateX: (size / 2 - 20) * Math.cos(2 * Math.PI * (i - 2) / count),
                translateY: (size / 2 - 20) * Math.sin(2 * Math.PI * (i - 2) / count),
                allowed: isAllowedFn ? isAllowedFn(i) : true
            }); });
        };
        ClockComponent.prototype.getPointerAngle = function (value, mode) {
            if (this.viewType === 'hours') {
                return this.mode === '12h' ? 360 / 12 * (value - 3) : 360 / 12 * (value % 12 - 3);
            }
            return 360 / 60 * (value - 15);
        };
        ClockComponent.prototype.getPointerValue = function (x, y, size) {
            var value;
            var angle = Math.atan2(size / 2 - x, size / 2 - y) / Math.PI * 180;
            if (angle < 0) {
                angle = 360 + angle;
            }
            if (this.viewType === 'hours') {
                if (this.mode === '12h') {
                    value = 12 - Math.round(angle * 12 / 360);
                    return value === 0 ? 12 : value;
                }
                var radius = Math.sqrt(Math.pow(size / 2 - x, 2) + Math.pow(size / 2 - y, 2));
                value = 12 - Math.round(angle * 12 / 360);
                if (value === 0) {
                    value = 12;
                }
                if (radius < size / 2 - 32) {
                    value = value === 12 ? 0 : value + 12;
                }
                return value;
            }
            value = Math.round(60 - 60 * angle / 360);
            return value === 60 ? 0 : value;
        };
        return ClockComponent;
    }());
    ClockComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mat-clock',
                    template: "<div class=\"root\">\n  <div class=\"circle\" (touchmove)=\"handleTouchMove($event)\" (mousemove)=\"handleMouseMove($event)\"\n    (touchstart)=\"disableAnimatedPointer()\" (mousedown)=\"disableAnimatedPointer()\" (touchend)=\"handleTouchEnd($event)\"\n    (mouseup)=\"enableAnimatedPointer()\" (click)=\"handleClick($event)\">\n    <div class=\"pointer-container\"\n      [ngClass]=\"{ 'small-pointer': mode === '24h' && viewType === 'hours' && (formattedValue === 0 || formattedValue > 12), 'animated-pointer': !touching }\"\n      [style.transform]=\"'rotate(' + angle + 'deg)'\">\n      <button mat-mini-fab [color]=\"color\" class=\"inner-dot\"></button>\n      <mat-toolbar [color]=\"color\" class=\"pointer\">\n        <button mat-mini-fab [color]=\"color\" class=\"outer-dot\"\n          [ngClass]=\" { 'outer-dot-odd': viewType === 'minutes' && formattedValue % 5 !== 0 }\">\n          <ng-container *ngIf=\"viewType === 'minutes' && formattedValue % 5 !== 0\">\u00B7</ng-container>\n        </button>\n      </mat-toolbar>\n    </div>\n    <ng-container *ngFor=\"let digit of minuteDots;\">\n      <button mat-mini-fab class=\"number minute-dot\"\n        [ngClass]=\"{ 'selected': formattedValue === digit.display || (digit.display === 0 && formattedValue === 0), 'disabled': !isAvailable(digit.display === 60 ? 0 : digit.display)}\"\n        [style.transform]=\"'translate(' + digit.translateX + 'px, ' + digit.translateY + 'px)'\">\n        <ng-container *ngIf=\"digit.display % 5 !== 0\">\u00B7</ng-container>\n      </button>\n    </ng-container>\n    <ng-container *ngFor=\"let digit of numbers;\">\n      <button mat-mini-fab [color]=\"color\" class=\"number\"\n        [ngClass]=\"{ 'selected': formattedValue === digit.display || (digit.display === 60 && formattedValue === 0), 'disabled': !isAvailable(digit.display === 60 ? 0 : digit.display)}\"\n        [style.transform]=\"'translate(' + digit.translateX + 'px, ' + digit.translateY + 'px)'\">\n        <ng-template #hoursTemplate>{{ digit.display }}</ng-template>\n        <ng-template #minutesTemplate>{{ digit.display === 60 ? '00' : digit.display }}</ng-template>\n        <ng-container *ngIf=\"viewType === 'minutes' then minutesTemplate else hoursTemplate;\"></ng-container>\n      </button>\n\n    </ng-container>\n    <ng-container *ngFor=\"let digit of secondaryNumbers;\">\n      <button mat-mini-fab [color]=\"color\" class=\"number small-number\"\n        [ngClass]=\"{ 'selected': formattedValue === digit.display || (digit.display === 24 && formattedValue === 0), 'disabled': !isAvailable(digit.display === 24 ? 0 : digit.display)}\"\n        [style.transform]=\"'translate(' + digit.translateX + 'px, ' + digit.translateY + 'px)'\">\n        {{ digit.display === 24 ? '00' : digit.display }}\n      </button>\n\n    </ng-container>\n  </div>",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".root{cursor:default}.circle,.root{height:256px;width:256px}.circle{background:#ededed;border-radius:50%;cursor:pointer;position:relative}.number{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;align-items:center;background-color:transparent;box-shadow:none;cursor:pointer;display:flex;flex-direction:column;font-size:14px;height:32px;justify-content:center;left:calc(50% - 16px);line-height:32px;pointer-events:none;position:absolute;text-align:center;top:calc(50% - 16px);user-select:none;width:32px}.number.disabled{color:rgba(1,1,1,.1)}.number:not(.selected):not(.disabled){color:rgba(0,0,0,.87)}.number:not(.disabled).minute-dot{color:rgba(1,1,1,.7)}.number:not(.disabled).minute-dot.selected{color:transparent}.small-number{font-size:12px}.small-number:not(.selected):not(.disabled){color:rgba(0,0,0,.67)}.pointer-container{height:2;left:50%;pointer-events:none;position:absolute;top:calc(50% - 1px);transform-origin:left center;width:calc(50% - 20px)}.pointer-container.disabled *{background-color:transparent}.pointer{height:1px}.animated-pointer{transition:all .2s ease-out}.small-pointer{width:calc(50% - 52px)}.inner-dot{height:8px;left:-4px;top:-3px;width:8px}.inner-dot,.outer-dot{border-radius:50%;box-shadow:none;position:absolute}.outer-dot{box-sizing:content-box;height:32px;right:-16px;width:32px}.outer-dot-odd{align-items:center;box-shadow:none;display:flex;flex-direction:column;height:32px;justify-content:center;width:32px}"]
                },] }
    ];
    ClockComponent.propDecorators = {
        mode: [{ type: core.Input }],
        viewType: [{ type: core.Input }],
        color: [{ type: core.Input }],
        formattedValue: [{ type: core.Input }],
        minDate: [{ type: core.Input }],
        maxDate: [{ type: core.Input }],
        isPm: [{ type: core.Input }],
        formattedHours: [{ type: core.Input }],
        minutes: [{ type: core.Input }],
        changeEvent: [{ type: core.Output }],
        unavailableSelection: [{ type: core.Output }],
        invalidMeridiem: [{ type: core.Output }],
        invalidSelection: [{ type: core.Output }],
        clearInvalidMeridiem: [{ type: core.Output }],
        allowed12HourMap: [{ type: core.Input }],
        allowed24HourMap: [{ type: core.Input }]
    };

    var MatTimepickerModule = /** @class */ (function () {
        function MatTimepickerModule() {
        }
        return MatTimepickerModule;
    }());
    MatTimepickerModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        ClockComponent,
                        MatTimepickerDirective,
                        MatTimepickerComponentDialogComponent
                    ],
                    imports: [
                        common.CommonModule,
                        dialog.MatDialogModule,
                        button.MatButtonModule,
                        toolbar.MatToolbarModule,
                        icon.MatIconModule,
                        input.MatInputModule
                    ],
                    exports: [
                        MatTimepickerDirective
                    ],
                    entryComponents: [
                        MatTimepickerComponentDialogComponent
                    ]
                },] }
    ];

    /*
     * Public API Surface of mat-timepicker
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.MatTimepickerDirective = MatTimepickerDirective;
    exports.MatTimepickerModule = MatTimepickerModule;
    exports.ɵa = ClockComponent;
    exports.ɵb = MatTimepickerComponentDialogComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=mat-timepicker.umd.js.map
