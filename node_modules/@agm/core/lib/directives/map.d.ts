/// <reference types="googlemaps" />
import { AfterContentInit, ElementRef, EventEmitter, NgZone, OnChanges, OnDestroy, QueryList, SimpleChanges } from '@angular/core';
import { FitBoundsService } from '../services/fit-bounds';
import { GoogleMapsAPIWrapper } from '../services/google-maps-api-wrapper';
import * as ɵngcc0 from '@angular/core';
export declare type ControlPosition = keyof typeof google.maps.ControlPosition;
export declare abstract class AgmMapControl {
    position: ControlPosition;
    abstract getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmMapControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmMapControl, never, never, {
    "position": "position";
}, {}, never>;
}
export declare class AgmFullscreenControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmFullscreenControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmFullscreenControl, "agm-map agm-fullscreen-control", never, {}, {}, never>;
}
export declare class AgmMapTypeControl extends AgmMapControl {
    mapTypeIds: (keyof typeof google.maps.MapTypeId)[];
    style: keyof typeof google.maps.MapTypeControlStyle;
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmMapTypeControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmMapTypeControl, "agm-map agm-map-type-control", never, {
    "mapTypeIds": "mapTypeIds";
    "style": "style";
}, {}, never>;
}
export declare class AgmPanControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmPanControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmPanControl, "agm-map agm-pan-control", never, {}, {}, never>;
}
export declare class AgmRotateControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmRotateControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmRotateControl, "agm-map agm-rotate-control", never, {}, {}, never>;
}
export declare class AgmScaleControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmScaleControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmScaleControl, "agm-map agm-scale-control", never, {}, {}, never>;
}
export declare class AgmStreetViewControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmStreetViewControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmStreetViewControl, "agm-map agm-street-view-control", never, {}, {}, never>;
}
export declare class AgmZoomControl extends AgmMapControl {
    style: keyof typeof google.maps.ZoomControlStyle;
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmZoomControl>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmZoomControl, "agm-map agm-zoom-control", never, {
    "style": "style";
}, {}, never>;
}
/**
 * AgmMap renders a Google Map.
 * **Important note**: To be able see a map in the browser, you have to define a height for the
 * element `agm-map`.
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    agm-map {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *    </agm-map>
 *  `
 * })
 * ```
 */
export declare class AgmMap implements OnChanges, AfterContentInit, OnDestroy {
    private _elem;
    private _mapsWrapper;
    private _platformId;
    protected _fitBoundsService: FitBoundsService;
    private _zone;
    /**
     * The longitude that defines the center of the map.
     */
    longitude: number;
    /**
     * The latitude that defines the center of the map.
     */
    latitude: number;
    /**
     * The zoom level of the map. The default zoom level is 8.
     */
    zoom: number;
    /**
     * The minimal zoom level of the map allowed. When not provided, no restrictions to the zoom level
     * are enforced.
     */
    minZoom: number;
    /**
     * The maximal zoom level of the map allowed. When not provided, no restrictions to the zoom level
     * are enforced.
     */
    maxZoom: number;
    /**
     * The control size for the default map controls. Only governs the controls made by the Maps API itself
     */
    controlSize: number;
    /**
     * Enables/disables if map is draggable.
     */
    draggable: boolean;
    /**
     * Enables/disables zoom and center on double click. Enabled by default.
     */
    disableDoubleClickZoom: boolean;
    /**
     * Enables/disables all default UI of the Google map. Please note: When the map is created, this
     * value cannot get updated.
     */
    disableDefaultUI: boolean;
    /**
     * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.
     */
    scrollwheel: boolean;
    /**
     * Color used for the background of the Map div. This color will be visible when tiles have not
     * yet loaded as the user pans. This option can only be set when the map is initialized.
     */
    backgroundColor: string;
    /**
     * The name or url of the cursor to display when mousing over a draggable map. This property uses
     * the css  * cursor attribute to change the icon. As with the css property, you must specify at
     * least one fallback cursor that is not a URL. For example:
     * [draggableCursor]="'url(http://www.example.com/icon.png), auto;'"
     */
    draggableCursor: string;
    /**
     * The name or url of the cursor to display when the map is being dragged. This property uses the
     * css cursor attribute to change the icon. As with the css property, you must specify at least
     * one fallback cursor that is not a URL. For example:
     * [draggingCursor]="'url(http://www.example.com/icon.png), auto;'"
     */
    draggingCursor: string;
    /**
     * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are
     * enabled by default.
     */
    keyboardShortcuts: boolean;
    /**
     * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain
     * modes, these styles will only apply to labels and geometry.
     */
    styles: google.maps.MapTypeStyle[];
    /**
     * When true and the latitude and/or longitude values changes, the Google Maps panTo method is
     * used to
     * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map
     */
    usePanning: boolean;
    /**
     * Sets the viewport to contain the given bounds.
     * If this option to `true`, the bounds get automatically computed from all elements that use the {@link AgmFitBounds} directive.
     */
    fitBounds: google.maps.LatLngBoundsLiteral | google.maps.LatLngBounds | boolean;
    /**
     * Padding amount for the bounds.
     */
    fitBoundsPadding: number | google.maps.Padding;
    /**
     * The map mapTypeId. Defaults to 'roadmap'.
     */
    mapTypeId: keyof typeof google.maps.MapTypeId;
    /**
     * When false, map icons are not clickable. A map icon represents a point of interest,
     * also known as a POI. By default map icons are clickable.
     */
    clickableIcons: boolean;
    /**
     * A map icon represents a point of interest, also known as a POI.
     * When map icons are clickable by default, an info window is displayed.
     * When this property is set to false, the info window will not be shown but the click event
     * will still fire
     */
    showDefaultInfoWindow: boolean;
    /**
     * This setting controls how gestures on the map are handled.
     * Allowed values:
     * - 'cooperative' (Two-finger touch gestures pan and zoom the map. One-finger touch gestures are not handled by the map.)
     * - 'greedy'      (All touch gestures pan or zoom the map.)
     * - 'none'        (The map cannot be panned or zoomed by user gestures.)
     * - 'auto'        [default] (Gesture handling is either cooperative or greedy, depending on whether the page is scrollable or not.
     */
    gestureHandling: google.maps.GestureHandlingOptions;
    /**
     * Controls the automatic switching behavior for the angle of incidence of
     * the map. The only allowed values are 0 and 45. The value 0 causes the map
     * to always use a 0° overhead view regardless of the zoom level and
     * viewport. The value 45 causes the tilt angle to automatically switch to
     * 45 whenever 45° imagery is available for the current zoom level and
     * viewport, and switch back to 0 whenever 45° imagery is not available
     * (this is the default behavior). 45° imagery is only available for
     * satellite and hybrid map types, within some locations, and at some zoom
     * levels. Note: getTilt returns the current tilt angle, not the value
     * specified by this option. Because getTilt and this option refer to
     * different things, do not bind() the tilt property; doing so may yield
     * unpredictable effects. (Default of AGM is 0 (disabled). Enable it with value 45.)
     */
    tilt: number;
    /**
     * Options for restricting the bounds of the map.
     * User cannot pan or zoom away from restricted area.
     */
    restriction: google.maps.MapRestriction;
    /**
     * Map option attributes that can change over time
     */
    private static _mapOptionsAttributes;
    private _observableSubscriptions;
    private _fitBoundsSubscription;
    /**
     * This event emitter gets emitted when the user clicks on the map (but not when they click on a
     * marker or infoWindow).
     */
    mapClick: EventEmitter<google.maps.MouseEvent | google.maps.IconMouseEvent>;
    /**
     * This event emitter gets emitted when the user right-clicks on the map (but not when they click
     * on a marker or infoWindow).
     */
    mapRightClick: EventEmitter<google.maps.MouseEvent>;
    /**
     * This event emitter gets emitted when the user double-clicks on the map (but not when they click
     * on a marker or infoWindow).
     */
    mapDblClick: EventEmitter<google.maps.MouseEvent>;
    /**
     * This event emitter is fired when the map center changes.
     */
    centerChange: EventEmitter<google.maps.LatLngLiteral>;
    /**
     * This event is fired when the viewport bounds have changed.
     */
    boundsChange: EventEmitter<google.maps.LatLngBounds>;
    /**
     * This event is fired when the mapTypeId property changes.
     */
    mapTypeIdChange: EventEmitter<google.maps.MapTypeId>;
    /**
     * This event is fired when the map becomes idle after panning or zooming.
     */
    idle: EventEmitter<void>;
    /**
     * This event is fired when the zoom level has changed.
     */
    zoomChange: EventEmitter<number>;
    /**
     * This event is fired when the google map is fully initialized.
     * You get the google.maps.Map instance as a result of this EventEmitter.
     */
    mapReady: EventEmitter<any>;
    /**
     * This event is fired when the visible tiles have finished loading.
     */
    tilesLoaded: EventEmitter<void>;
    mapControls: QueryList<AgmMapControl>;
    constructor(_elem: ElementRef, _mapsWrapper: GoogleMapsAPIWrapper, _platformId: Object, _fitBoundsService: FitBoundsService, _zone: NgZone);
    /** @internal */
    ngAfterContentInit(): void;
    private _initMapInstance;
    /** @internal */
    ngOnDestroy(): void;
    ngOnChanges(changes: SimpleChanges): void;
    private _updateMapOptionsChanges;
    /**
     * Triggers a resize event on the google map instance.
     * When recenter is true, the of the google map gets called with the current lat/lng values or fitBounds value to recenter the map.
     * Returns a promise that gets resolved after the event was triggered.
     */
    triggerResize(recenter?: boolean): Promise<void>;
    private _updatePosition;
    private _setCenter;
    private _fitBounds;
    private _subscribeToFitBoundsUpdates;
    protected _updateBounds(bounds: google.maps.LatLngBounds | google.maps.LatLngBoundsLiteral, padding?: number | google.maps.Padding): void;
    private _isLatLngBoundsLiteral;
    private _handleMapCenterChange;
    private _handleBoundsChange;
    private _handleMapTypeIdChange;
    private _handleMapZoomChange;
    private _handleIdleEvent;
    private _handleTilesLoadedEvent;
    private _handleMapMouseEvents;
    _handleControlChange(): void;
    _setControls(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmMap>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<AgmMap, "agm-map", never, {
    "longitude": "longitude";
    "latitude": "latitude";
    "zoom": "zoom";
    "draggable": "mapDraggable";
    "disableDoubleClickZoom": "disableDoubleClickZoom";
    "disableDefaultUI": "disableDefaultUI";
    "scrollwheel": "scrollwheel";
    "keyboardShortcuts": "keyboardShortcuts";
    "styles": "styles";
    "usePanning": "usePanning";
    "fitBounds": "fitBounds";
    "mapTypeId": "mapTypeId";
    "clickableIcons": "clickableIcons";
    "showDefaultInfoWindow": "showDefaultInfoWindow";
    "gestureHandling": "gestureHandling";
    "tilt": "tilt";
    "minZoom": "minZoom";
    "maxZoom": "maxZoom";
    "controlSize": "controlSize";
    "backgroundColor": "backgroundColor";
    "draggableCursor": "draggableCursor";
    "draggingCursor": "draggingCursor";
    "fitBoundsPadding": "fitBoundsPadding";
    "restriction": "restriction";
}, {
    "mapClick": "mapClick";
    "mapRightClick": "mapRightClick";
    "mapDblClick": "mapDblClick";
    "centerChange": "centerChange";
    "boundsChange": "boundsChange";
    "mapTypeIdChange": "mapTypeIdChange";
    "idle": "idle";
    "zoomChange": "zoomChange";
    "mapReady": "mapReady";
    "tilesLoaded": "tilesLoaded";
}, ["mapControls"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLmQudHMiLCJzb3VyY2VzIjpbIm1hcC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUlBOzs7Ozs7OztBQUlBOzs7OztBQUdBOzs7Ozs7Ozs7O0FBS0E7Ozs7O0FBR0E7Ozs7O0FBR0E7Ozs7O0FBR0E7Ozs7O0FBR0E7Ozs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrUEEiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cImdvb2dsZW1hcHNcIiAvPlxuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBOZ1pvbmUsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBRdWVyeUxpc3QsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZpdEJvdW5kc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9maXQtYm91bmRzJztcbmltcG9ydCB7IEdvb2dsZU1hcHNBUElXcmFwcGVyIH0gZnJvbSAnLi4vc2VydmljZXMvZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInO1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBDb250cm9sUG9zaXRpb24gPSBrZXlvZiB0eXBlb2YgZ29vZ2xlLm1hcHMuQ29udHJvbFBvc2l0aW9uO1xuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgQWdtTWFwQ29udHJvbCB7XG4gICAgcG9zaXRpb246IENvbnRyb2xQb3NpdGlvbjtcbiAgICBhYnN0cmFjdCBnZXRPcHRpb25zKCk6IFBhcnRpYWw8Z29vZ2xlLm1hcHMuTWFwT3B0aW9ucz47XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ21GdWxsc2NyZWVuQ29udHJvbCBleHRlbmRzIEFnbU1hcENvbnRyb2wge1xuICAgIGdldE9wdGlvbnMoKTogUGFydGlhbDxnb29nbGUubWFwcy5NYXBPcHRpb25zPjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFnbU1hcFR5cGVDb250cm9sIGV4dGVuZHMgQWdtTWFwQ29udHJvbCB7XG4gICAgbWFwVHlwZUlkczogKGtleW9mIHR5cGVvZiBnb29nbGUubWFwcy5NYXBUeXBlSWQpW107XG4gICAgc3R5bGU6IGtleW9mIHR5cGVvZiBnb29nbGUubWFwcy5NYXBUeXBlQ29udHJvbFN0eWxlO1xuICAgIGdldE9wdGlvbnMoKTogUGFydGlhbDxnb29nbGUubWFwcy5NYXBPcHRpb25zPjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFnbVBhbkNvbnRyb2wgZXh0ZW5kcyBBZ21NYXBDb250cm9sIHtcbiAgICBnZXRPcHRpb25zKCk6IFBhcnRpYWw8Z29vZ2xlLm1hcHMuTWFwT3B0aW9ucz47XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ21Sb3RhdGVDb250cm9sIGV4dGVuZHMgQWdtTWFwQ29udHJvbCB7XG4gICAgZ2V0T3B0aW9ucygpOiBQYXJ0aWFsPGdvb2dsZS5tYXBzLk1hcE9wdGlvbnM+O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQWdtU2NhbGVDb250cm9sIGV4dGVuZHMgQWdtTWFwQ29udHJvbCB7XG4gICAgZ2V0T3B0aW9ucygpOiBQYXJ0aWFsPGdvb2dsZS5tYXBzLk1hcE9wdGlvbnM+O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQWdtU3RyZWV0Vmlld0NvbnRyb2wgZXh0ZW5kcyBBZ21NYXBDb250cm9sIHtcbiAgICBnZXRPcHRpb25zKCk6IFBhcnRpYWw8Z29vZ2xlLm1hcHMuTWFwT3B0aW9ucz47XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ21ab29tQ29udHJvbCBleHRlbmRzIEFnbU1hcENvbnRyb2wge1xuICAgIHN0eWxlOiBrZXlvZiB0eXBlb2YgZ29vZ2xlLm1hcHMuWm9vbUNvbnRyb2xTdHlsZTtcbiAgICBnZXRPcHRpb25zKCk6IFBhcnRpYWw8Z29vZ2xlLm1hcHMuTWFwT3B0aW9ucz47XG59XG4vKipcbiAqIEFnbU1hcCByZW5kZXJzIGEgR29vZ2xlIE1hcC5cbiAqICoqSW1wb3J0YW50IG5vdGUqKjogVG8gYmUgYWJsZSBzZWUgYSBtYXAgaW4gdGhlIGJyb3dzZXIsIHlvdSBoYXZlIHRvIGRlZmluZSBhIGhlaWdodCBmb3IgdGhlXG4gKiBlbGVtZW50IGBhZ20tbWFwYC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICBhZ20tbWFwIHtcbiAqICAgICAgaGVpZ2h0OiAzMDBweDtcbiAqICAgIH1cbiAqIGBdLFxuICogIHRlbXBsYXRlOiBgXG4gKiAgICA8YWdtLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICA8L2FnbS1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ21NYXAgaW1wbGVtZW50cyBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfZWxlbTtcbiAgICBwcml2YXRlIF9tYXBzV3JhcHBlcjtcbiAgICBwcml2YXRlIF9wbGF0Zm9ybUlkO1xuICAgIHByb3RlY3RlZCBfZml0Qm91bmRzU2VydmljZTogRml0Qm91bmRzU2VydmljZTtcbiAgICBwcml2YXRlIF96b25lO1xuICAgIC8qKlxuICAgICAqIFRoZSBsb25naXR1ZGUgdGhhdCBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cbiAgICAgKi9cbiAgICBsb25naXR1ZGU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgbGF0aXR1ZGUgdGhhdCBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cbiAgICAgKi9cbiAgICBsYXRpdHVkZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFRoZSBkZWZhdWx0IHpvb20gbGV2ZWwgaXMgOC5cbiAgICAgKi9cbiAgICB6b29tOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltYWwgem9vbSBsZXZlbCBvZiB0aGUgbWFwIGFsbG93ZWQuIFdoZW4gbm90IHByb3ZpZGVkLCBubyByZXN0cmljdGlvbnMgdG8gdGhlIHpvb20gbGV2ZWxcbiAgICAgKiBhcmUgZW5mb3JjZWQuXG4gICAgICovXG4gICAgbWluWm9vbTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbWFsIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCBhbGxvd2VkLiBXaGVuIG5vdCBwcm92aWRlZCwgbm8gcmVzdHJpY3Rpb25zIHRvIHRoZSB6b29tIGxldmVsXG4gICAgICogYXJlIGVuZm9yY2VkLlxuICAgICAqL1xuICAgIG1heFpvb206IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBzaXplIGZvciB0aGUgZGVmYXVsdCBtYXAgY29udHJvbHMuIE9ubHkgZ292ZXJucyB0aGUgY29udHJvbHMgbWFkZSBieSB0aGUgTWFwcyBBUEkgaXRzZWxmXG4gICAgICovXG4gICAgY29udHJvbFNpemU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIGlmIG1hcCBpcyBkcmFnZ2FibGUuXG4gICAgICovXG4gICAgZHJhZ2dhYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgem9vbSBhbmQgY2VudGVyIG9uIGRvdWJsZSBjbGljay4gRW5hYmxlZCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIGRpc2FibGVEb3VibGVDbGlja1pvb206IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW5hYmxlcy9kaXNhYmxlcyBhbGwgZGVmYXVsdCBVSSBvZiB0aGUgR29vZ2xlIG1hcC4gUGxlYXNlIG5vdGU6IFdoZW4gdGhlIG1hcCBpcyBjcmVhdGVkLCB0aGlzXG4gICAgICogdmFsdWUgY2Fubm90IGdldCB1cGRhdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVEZWZhdWx0VUk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgZmFsc2UsIGRpc2FibGVzIHNjcm9sbHdoZWVsIHpvb21pbmcgb24gdGhlIG1hcC4gVGhlIHNjcm9sbHdoZWVsIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBzY3JvbGx3aGVlbDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDb2xvciB1c2VkIGZvciB0aGUgYmFja2dyb3VuZCBvZiB0aGUgTWFwIGRpdi4gVGhpcyBjb2xvciB3aWxsIGJlIHZpc2libGUgd2hlbiB0aWxlcyBoYXZlIG5vdFxuICAgICAqIHlldCBsb2FkZWQgYXMgdGhlIHVzZXIgcGFucy4gVGhpcyBvcHRpb24gY2FuIG9ubHkgYmUgc2V0IHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvciB1cmwgb2YgdGhlIGN1cnNvciB0byBkaXNwbGF5IHdoZW4gbW91c2luZyBvdmVyIGEgZHJhZ2dhYmxlIG1hcC4gVGhpcyBwcm9wZXJ0eSB1c2VzXG4gICAgICogdGhlIGNzcyAgKiBjdXJzb3IgYXR0cmlidXRlIHRvIGNoYW5nZSB0aGUgaWNvbi4gQXMgd2l0aCB0aGUgY3NzIHByb3BlcnR5LCB5b3UgbXVzdCBzcGVjaWZ5IGF0XG4gICAgICogbGVhc3Qgb25lIGZhbGxiYWNrIGN1cnNvciB0aGF0IGlzIG5vdCBhIFVSTC4gRm9yIGV4YW1wbGU6XG4gICAgICogW2RyYWdnYWJsZUN1cnNvcl09XCIndXJsKGh0dHA6Ly93d3cuZXhhbXBsZS5jb20vaWNvbi5wbmcpLCBhdXRvOydcIlxuICAgICAqL1xuICAgIGRyYWdnYWJsZUN1cnNvcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9yIHVybCBvZiB0aGUgY3Vyc29yIHRvIGRpc3BsYXkgd2hlbiB0aGUgbWFwIGlzIGJlaW5nIGRyYWdnZWQuIFRoaXMgcHJvcGVydHkgdXNlcyB0aGVcbiAgICAgKiBjc3MgY3Vyc29yIGF0dHJpYnV0ZSB0byBjaGFuZ2UgdGhlIGljb24uIEFzIHdpdGggdGhlIGNzcyBwcm9wZXJ0eSwgeW91IG11c3Qgc3BlY2lmeSBhdCBsZWFzdFxuICAgICAqIG9uZSBmYWxsYmFjayBjdXJzb3IgdGhhdCBpcyBub3QgYSBVUkwuIEZvciBleGFtcGxlOlxuICAgICAqIFtkcmFnZ2luZ0N1cnNvcl09XCIndXJsKGh0dHA6Ly93d3cuZXhhbXBsZS5jb20vaWNvbi5wbmcpLCBhdXRvOydcIlxuICAgICAqL1xuICAgIGRyYWdnaW5nQ3Vyc29yOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSWYgZmFsc2UsIHByZXZlbnRzIHRoZSBtYXAgZnJvbSBiZWluZyBjb250cm9sbGVkIGJ5IHRoZSBrZXlib2FyZC4gS2V5Ym9hcmQgc2hvcnRjdXRzIGFyZVxuICAgICAqIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBrZXlib2FyZFNob3J0Y3V0czogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTdHlsZXMgdG8gYXBwbHkgdG8gZWFjaCBvZiB0aGUgZGVmYXVsdCBtYXAgdHlwZXMuIE5vdGUgdGhhdCBmb3IgU2F0ZWxsaXRlL0h5YnJpZCBhbmQgVGVycmFpblxuICAgICAqIG1vZGVzLCB0aGVzZSBzdHlsZXMgd2lsbCBvbmx5IGFwcGx5IHRvIGxhYmVscyBhbmQgZ2VvbWV0cnkuXG4gICAgICovXG4gICAgc3R5bGVzOiBnb29nbGUubWFwcy5NYXBUeXBlU3R5bGVbXTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUgYW5kIHRoZSBsYXRpdHVkZSBhbmQvb3IgbG9uZ2l0dWRlIHZhbHVlcyBjaGFuZ2VzLCB0aGUgR29vZ2xlIE1hcHMgcGFuVG8gbWV0aG9kIGlzXG4gICAgICogdXNlZCB0b1xuICAgICAqIGNlbnRlciB0aGUgbWFwLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNNYXBcbiAgICAgKi9cbiAgICB1c2VQYW5uaW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpZXdwb3J0IHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kcy5cbiAgICAgKiBJZiB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAsIHRoZSBib3VuZHMgZ2V0IGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgZnJvbSBhbGwgZWxlbWVudHMgdGhhdCB1c2UgdGhlIHtAbGluayBBZ21GaXRCb3VuZHN9IGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBmaXRCb3VuZHM6IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kc0xpdGVyYWwgfCBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMgfCBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFBhZGRpbmcgYW1vdW50IGZvciB0aGUgYm91bmRzLlxuICAgICAqL1xuICAgIGZpdEJvdW5kc1BhZGRpbmc6IG51bWJlciB8IGdvb2dsZS5tYXBzLlBhZGRpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBtYXBUeXBlSWQuIERlZmF1bHRzIHRvICdyb2FkbWFwJy5cbiAgICAgKi9cbiAgICBtYXBUeXBlSWQ6IGtleW9mIHR5cGVvZiBnb29nbGUubWFwcy5NYXBUeXBlSWQ7XG4gICAgLyoqXG4gICAgICogV2hlbiBmYWxzZSwgbWFwIGljb25zIGFyZSBub3QgY2xpY2thYmxlLiBBIG1hcCBpY29uIHJlcHJlc2VudHMgYSBwb2ludCBvZiBpbnRlcmVzdCxcbiAgICAgKiBhbHNvIGtub3duIGFzIGEgUE9JLiBCeSBkZWZhdWx0IG1hcCBpY29ucyBhcmUgY2xpY2thYmxlLlxuICAgICAqL1xuICAgIGNsaWNrYWJsZUljb25zOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgbWFwIGljb24gcmVwcmVzZW50cyBhIHBvaW50IG9mIGludGVyZXN0LCBhbHNvIGtub3duIGFzIGEgUE9JLlxuICAgICAqIFdoZW4gbWFwIGljb25zIGFyZSBjbGlja2FibGUgYnkgZGVmYXVsdCwgYW4gaW5mbyB3aW5kb3cgaXMgZGlzcGxheWVkLlxuICAgICAqIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gZmFsc2UsIHRoZSBpbmZvIHdpbmRvdyB3aWxsIG5vdCBiZSBzaG93biBidXQgdGhlIGNsaWNrIGV2ZW50XG4gICAgICogd2lsbCBzdGlsbCBmaXJlXG4gICAgICovXG4gICAgc2hvd0RlZmF1bHRJbmZvV2luZG93OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoaXMgc2V0dGluZyBjb250cm9scyBob3cgZ2VzdHVyZXMgb24gdGhlIG1hcCBhcmUgaGFuZGxlZC5cbiAgICAgKiBBbGxvd2VkIHZhbHVlczpcbiAgICAgKiAtICdjb29wZXJhdGl2ZScgKFR3by1maW5nZXIgdG91Y2ggZ2VzdHVyZXMgcGFuIGFuZCB6b29tIHRoZSBtYXAuIE9uZS1maW5nZXIgdG91Y2ggZ2VzdHVyZXMgYXJlIG5vdCBoYW5kbGVkIGJ5IHRoZSBtYXAuKVxuICAgICAqIC0gJ2dyZWVkeScgICAgICAoQWxsIHRvdWNoIGdlc3R1cmVzIHBhbiBvciB6b29tIHRoZSBtYXAuKVxuICAgICAqIC0gJ25vbmUnICAgICAgICAoVGhlIG1hcCBjYW5ub3QgYmUgcGFubmVkIG9yIHpvb21lZCBieSB1c2VyIGdlc3R1cmVzLilcbiAgICAgKiAtICdhdXRvJyAgICAgICAgW2RlZmF1bHRdIChHZXN0dXJlIGhhbmRsaW5nIGlzIGVpdGhlciBjb29wZXJhdGl2ZSBvciBncmVlZHksIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBwYWdlIGlzIHNjcm9sbGFibGUgb3Igbm90LlxuICAgICAqL1xuICAgIGdlc3R1cmVIYW5kbGluZzogZ29vZ2xlLm1hcHMuR2VzdHVyZUhhbmRsaW5nT3B0aW9ucztcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB0aGUgYXV0b21hdGljIHN3aXRjaGluZyBiZWhhdmlvciBmb3IgdGhlIGFuZ2xlIG9mIGluY2lkZW5jZSBvZlxuICAgICAqIHRoZSBtYXAuIFRoZSBvbmx5IGFsbG93ZWQgdmFsdWVzIGFyZSAwIGFuZCA0NS4gVGhlIHZhbHVlIDAgY2F1c2VzIHRoZSBtYXBcbiAgICAgKiB0byBhbHdheXMgdXNlIGEgMMKwIG92ZXJoZWFkIHZpZXcgcmVnYXJkbGVzcyBvZiB0aGUgem9vbSBsZXZlbCBhbmRcbiAgICAgKiB2aWV3cG9ydC4gVGhlIHZhbHVlIDQ1IGNhdXNlcyB0aGUgdGlsdCBhbmdsZSB0byBhdXRvbWF0aWNhbGx5IHN3aXRjaCB0b1xuICAgICAqIDQ1IHdoZW5ldmVyIDQ1wrAgaW1hZ2VyeSBpcyBhdmFpbGFibGUgZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYW5kXG4gICAgICogdmlld3BvcnQsIGFuZCBzd2l0Y2ggYmFjayB0byAwIHdoZW5ldmVyIDQ1wrAgaW1hZ2VyeSBpcyBub3QgYXZhaWxhYmxlXG4gICAgICogKHRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IpLiA0NcKwIGltYWdlcnkgaXMgb25seSBhdmFpbGFibGUgZm9yXG4gICAgICogc2F0ZWxsaXRlIGFuZCBoeWJyaWQgbWFwIHR5cGVzLCB3aXRoaW4gc29tZSBsb2NhdGlvbnMsIGFuZCBhdCBzb21lIHpvb21cbiAgICAgKiBsZXZlbHMuIE5vdGU6IGdldFRpbHQgcmV0dXJucyB0aGUgY3VycmVudCB0aWx0IGFuZ2xlLCBub3QgdGhlIHZhbHVlXG4gICAgICogc3BlY2lmaWVkIGJ5IHRoaXMgb3B0aW9uLiBCZWNhdXNlIGdldFRpbHQgYW5kIHRoaXMgb3B0aW9uIHJlZmVyIHRvXG4gICAgICogZGlmZmVyZW50IHRoaW5ncywgZG8gbm90IGJpbmQoKSB0aGUgdGlsdCBwcm9wZXJ0eTsgZG9pbmcgc28gbWF5IHlpZWxkXG4gICAgICogdW5wcmVkaWN0YWJsZSBlZmZlY3RzLiAoRGVmYXVsdCBvZiBBR00gaXMgMCAoZGlzYWJsZWQpLiBFbmFibGUgaXQgd2l0aCB2YWx1ZSA0NS4pXG4gICAgICovXG4gICAgdGlsdDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgZm9yIHJlc3RyaWN0aW5nIHRoZSBib3VuZHMgb2YgdGhlIG1hcC5cbiAgICAgKiBVc2VyIGNhbm5vdCBwYW4gb3Igem9vbSBhd2F5IGZyb20gcmVzdHJpY3RlZCBhcmVhLlxuICAgICAqL1xuICAgIHJlc3RyaWN0aW9uOiBnb29nbGUubWFwcy5NYXBSZXN0cmljdGlvbjtcbiAgICAvKipcbiAgICAgKiBNYXAgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBjYW4gY2hhbmdlIG92ZXIgdGltZVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIF9tYXBPcHRpb25zQXR0cmlidXRlcztcbiAgICBwcml2YXRlIF9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucztcbiAgICBwcml2YXRlIF9maXRCb3VuZHNTdWJzY3JpcHRpb247XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGljayBvbiBhXG4gICAgICogbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAqL1xuICAgIG1hcENsaWNrOiBFdmVudEVtaXR0ZXI8Z29vZ2xlLm1hcHMuTW91c2VFdmVudCB8IGdvb2dsZS5tYXBzLkljb25Nb3VzZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICogb24gYSBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXG4gICAgICovXG4gICAgbWFwUmlnaHRDbGljazogRXZlbnRFbWl0dGVyPGdvb2dsZS5tYXBzLk1vdXNlRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICogb24gYSBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXG4gICAgICovXG4gICAgbWFwRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxnb29nbGUubWFwcy5Nb3VzZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGNlbnRlciBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGNlbnRlckNoYW5nZTogRXZlbnRFbWl0dGVyPGdvb2dsZS5tYXBzLkxhdExuZ0xpdGVyYWw+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdmlld3BvcnQgYm91bmRzIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBib3VuZHNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxnb29nbGUubWFwcy5MYXRMbmdCb3VuZHM+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgbWFwVHlwZUlkIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICovXG4gICAgbWFwVHlwZUlkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Z29vZ2xlLm1hcHMuTWFwVHlwZUlkPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBiZWNvbWVzIGlkbGUgYWZ0ZXIgcGFubmluZyBvciB6b29taW5nLlxuICAgICAqL1xuICAgIGlkbGU6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHpvb20gbGV2ZWwgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgem9vbUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBnb29nbGUgbWFwIGlzIGZ1bGx5IGluaXRpYWxpemVkLlxuICAgICAqIFlvdSBnZXQgdGhlIGdvb2dsZS5tYXBzLk1hcCBpbnN0YW5jZSBhcyBhIHJlc3VsdCBvZiB0aGlzIEV2ZW50RW1pdHRlci5cbiAgICAgKi9cbiAgICBtYXBSZWFkeTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB2aXNpYmxlIHRpbGVzIGhhdmUgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgKi9cbiAgICB0aWxlc0xvYWRlZDogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIG1hcENvbnRyb2xzOiBRdWVyeUxpc3Q8QWdtTWFwQ29udHJvbD47XG4gICAgY29uc3RydWN0b3IoX2VsZW06IEVsZW1lbnRSZWYsIF9tYXBzV3JhcHBlcjogR29vZ2xlTWFwc0FQSVdyYXBwZXIsIF9wbGF0Zm9ybUlkOiBPYmplY3QsIF9maXRCb3VuZHNTZXJ2aWNlOiBGaXRCb3VuZHNTZXJ2aWNlLCBfem9uZTogTmdab25lKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfaW5pdE1hcEluc3RhbmNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIHByaXZhdGUgX3VwZGF0ZU1hcE9wdGlvbnNDaGFuZ2VzO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgcmVzaXplIGV2ZW50IG9uIHRoZSBnb29nbGUgbWFwIGluc3RhbmNlLlxuICAgICAqIFdoZW4gcmVjZW50ZXIgaXMgdHJ1ZSwgdGhlIG9mIHRoZSBnb29nbGUgbWFwIGdldHMgY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgbGF0L2xuZyB2YWx1ZXMgb3IgZml0Qm91bmRzIHZhbHVlIHRvIHJlY2VudGVyIHRoZSBtYXAuXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIGFmdGVyIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqL1xuICAgIHRyaWdnZXJSZXNpemUocmVjZW50ZXI/OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcbiAgICBwcml2YXRlIF91cGRhdGVQb3NpdGlvbjtcbiAgICBwcml2YXRlIF9zZXRDZW50ZXI7XG4gICAgcHJpdmF0ZSBfZml0Qm91bmRzO1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvRml0Qm91bmRzVXBkYXRlcztcbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZUJvdW5kcyhib3VuZHM6IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyB8IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kc0xpdGVyYWwsIHBhZGRpbmc/OiBudW1iZXIgfCBnb29nbGUubWFwcy5QYWRkaW5nKTogdm9pZDtcbiAgICBwcml2YXRlIF9pc0xhdExuZ0JvdW5kc0xpdGVyYWw7XG4gICAgcHJpdmF0ZSBfaGFuZGxlTWFwQ2VudGVyQ2hhbmdlO1xuICAgIHByaXZhdGUgX2hhbmRsZUJvdW5kc0NoYW5nZTtcbiAgICBwcml2YXRlIF9oYW5kbGVNYXBUeXBlSWRDaGFuZ2U7XG4gICAgcHJpdmF0ZSBfaGFuZGxlTWFwWm9vbUNoYW5nZTtcbiAgICBwcml2YXRlIF9oYW5kbGVJZGxlRXZlbnQ7XG4gICAgcHJpdmF0ZSBfaGFuZGxlVGlsZXNMb2FkZWRFdmVudDtcbiAgICBwcml2YXRlIF9oYW5kbGVNYXBNb3VzZUV2ZW50cztcbiAgICBfaGFuZGxlQ29udHJvbENoYW5nZSgpOiB2b2lkO1xuICAgIF9zZXRDb250cm9scygpOiB2b2lkO1xufVxuIl19